
<!DOCTYPE html>


<html lang="en" data-content_root="../../../" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>pybads.bads.bads &#8212; PyBADS</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "";
  </script>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="../../../_static/styles/theme.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
<link href="../../../_static/styles/bootstrap.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
<link href="../../../_static/styles/pydata-sphinx-theme.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />

  
  <link href="../../../_static/vendor/fontawesome/6.5.2/css/all.min.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
  <link rel="preload" as="font" type="font/woff2" crossorigin href="../../../_static/vendor/fontawesome/6.5.2/webfonts/fa-solid-900.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../../../_static/vendor/fontawesome/6.5.2/webfonts/fa-brands-400.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../../../_static/vendor/fontawesome/6.5.2/webfonts/fa-regular-400.woff2" />

    <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=8f2a1f02" />
    <link rel="stylesheet" type="text/css" href="../../../_static/styles/sphinx-book-theme.css?v=eba8b062" />
    <link rel="stylesheet" type="text/css" href="../../../_static/mystnb.8ecb98da25f57f5357bf6f572d296f466b2cfe2517ffebfabe82451661e28f02.css" />
  
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../../../_static/scripts/bootstrap.js?digest=dfe6caa3a7d634c4db9b" />
<link rel="preload" as="script" href="../../../_static/scripts/pydata-sphinx-theme.js?digest=dfe6caa3a7d634c4db9b" />
  <script src="../../../_static/vendor/fontawesome/6.5.2/js/all.min.js?digest=dfe6caa3a7d634c4db9b"></script>

    <script src="../../../_static/documentation_options.js?v=9eb32ce0"></script>
    <script src="../../../_static/doctools.js?v=9bcbadda"></script>
    <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../../_static/scripts/sphinx-book-theme.js?v=887ef09a"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = '_modules/pybads/bads/bads';</script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <link rel="canonical" href="https://acerbilab.github.io/pybads/_modules/pybads/bads/bads.html" />
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <div id="pst-skip-link" class="skip-link d-print-none"><a href="#main-content">Skip to main content</a></div>
  
  <div id="pst-scroll-pixel-helper"></div>
  
  <button type="button" class="btn rounded-pill" id="pst-back-to-top">
    <i class="fa-solid fa-arrow-up"></i>Back to top</button>

  
  <input type="checkbox"
          class="sidebar-toggle"
          id="pst-primary-sidebar-checkbox"/>
  <label class="overlay overlay-primary" for="pst-primary-sidebar-checkbox"></label>
  
  <input type="checkbox"
          class="sidebar-toggle"
          id="pst-secondary-sidebar-checkbox"/>
  <label class="overlay overlay-secondary" for="pst-secondary-sidebar-checkbox"></label>
  
  <div class="search-button__wrapper">
    <div class="search-button__overlay"></div>
    <div class="search-button__search-container">
<form class="bd-search d-flex align-items-center"
      action="../../../search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         id="search-input"
         placeholder="Search..."
         aria-label="Search..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form></div>
  </div>

  <div class="pst-async-banner-revealer d-none">
  <aside id="bd-header-version-warning" class="d-none d-print-none" aria-label="Version warning"></aside>
</div>

  
    <header class="bd-header navbar navbar-expand-lg bd-navbar d-print-none">
    </header>
  

  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      
      
        
      
      <div class="bd-sidebar-primary bd-sidebar">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
    
    
  </div>
  
    <div class="sidebar-primary-items__start sidebar-primary__section">
        <div class="sidebar-primary-item">

  
    
  

<a class="navbar-brand logo" href="../../../index.html">
  
  
  
  
  
  
    <p class="title logo__title">PyBADS</p>
  
</a></div>
        <div class="sidebar-primary-item">

 <script>
 document.write(`
   <button class="btn search-button-field search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass"></i>
    <span class="search-button__default-text">Search</span>
    <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
   </button>
 `);
 </script></div>
        <div class="sidebar-primary-item"><nav class="bd-links bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item navbar-nav active">
        <ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../../../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../quickstart.html">Getting started</a></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../../examples.html">Examples</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../_examples/pybads_example_1_basic_usage.html">PyBADS Example 1: Basic usage</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../_examples/pybads_example_2_nonbox_constraints.html">PyBADS Example 2: Non-box constraints</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../_examples/pybads_example_3_noisy_objective.html">PyBADS Example 3: Noisy objective function</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../_examples/pybads_example_4_user_provided_noise.html">PyBADS Example 4: Noisy objective with user-provided noise estimates</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../_examples/pybads_example_5_extended_usage.html">PyBADS Example 5: Extended usage</a></li>
</ul>
</details></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../../documentation.html">Documentation</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../api/classes/bads.html"><code class="docutils literal notranslate"><span class="pre">BADS</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../api/classes/optimize_result.html"><code class="docutils literal notranslate"><span class="pre">OptimizeResult</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../api/options/bads_options.html">BADS options</a></li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../../../api/advanced_docs.html">Advanced documentation</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l3 has-children"><a class="reference internal" href="../../../api/classes/classes.html">Classes</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../api/classes/bads.html"><code class="docutils literal notranslate"><span class="pre">BADS</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../api/classes/function_logger.html"><code class="docutils literal notranslate"><span class="pre">FunctionLogger</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../api/classes/iteration_history.html"><code class="docutils literal notranslate"><span class="pre">IterationHistory</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../api/classes/optimize_result.html"><code class="docutils literal notranslate"><span class="pre">OptimizeResult</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../api/classes/options.html"><code class="docutils literal notranslate"><span class="pre">Options</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../api/classes/parameter_transformer.html"><code class="docutils literal notranslate"><span class="pre">VariableTransformer</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../api/classes/timer.html"><code class="docutils literal notranslate"><span class="pre">Timer</span></code></a></li>
</ul>
</details></li>
<li class="toctree-l3 has-children"><a class="reference internal" href="../../../api/functions/functions.html">Functions</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../api/functions/acquisition_functions.html">Acquisition Functions</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../api/functions/decorators.html">Decorators</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../api/functions/get_hpd.html"><code class="docutils literal notranslate"><span class="pre">get_hpd</span></code></a></li>
</ul>
</details></li>
<li class="toctree-l3"><a class="reference internal" href="../../../api/options/bads_options.html">BADS options</a></li>
</ul>
</details></li>
</ul>
</details></li>
</ul>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../../../development.html">Instructions for developers and contributors</a></li>
</ul>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../../../about_us.html">About us</a></li>
</ul>

    </div>
</nav></div>
    </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
  </div>
  
  <div id="rtd-footer-container"></div>


      </div>
      
      <main id="main-content" class="bd-main" role="main">
        
        

<div class="sbt-scroll-pixel-helper"></div>

          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article d-print-none">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item"><button class="sidebar-toggle primary-toggle btn btn-sm" title="Toggle primary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
  <span class="fa-solid fa-bars"></span>
</button></div>
      
    </div>
  
  
    <div class="header-article-items__end">
      
        <div class="header-article-item">

<div class="article-header-buttons">





<div class="dropdown dropdown-source-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Source repositories">
    <i class="fab fa-github"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="https://github.com/acerbilab/pybads" target="_blank"
   class="btn btn-sm btn-source-repository-button dropdown-item"
   title="Source repository"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fab fa-github"></i>
  </span>
<span class="btn__text-container">Repository</span>
</a>
</li>
      
      
      
      
      <li><a href="https://github.com/acerbilab/pybads/issues/new?title=Issue%20on%20page%20%2F_modules/pybads/bads/bads.html&body=Your%20issue%20content%20here." target="_blank"
   class="btn btn-sm btn-source-issues-button dropdown-item"
   title="Open an issue"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-lightbulb"></i>
  </span>
<span class="btn__text-container">Open issue</span>
</a>
</li>
      
  </ul>
</div>




<button onclick="toggleFullScreen()"
  class="btn btn-sm btn-fullscreen-button"
  title="Fullscreen mode"
  data-bs-placement="bottom" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>



<script>
document.write(`
  <button class="btn btn-sm nav-link pst-navbar-icon theme-switch-button" title="light/dark" aria-label="light/dark" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="theme-switch fa-solid fa-sun fa-lg" data-mode="light"></i>
    <i class="theme-switch fa-solid fa-moon fa-lg" data-mode="dark"></i>
    <i class="theme-switch fa-solid fa-circle-half-stroke fa-lg" data-mode="auto"></i>
  </button>
`);
</script>


<script>
document.write(`
  <button class="btn btn-sm pst-navbar-icon search-button search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass fa-lg"></i>
  </button>
`);
</script>

</div></div>
      
    </div>
  
</div>
</div>
              
              

<div id="jb-print-docs-body" class="onlyprint">
    <h1></h1>
    <!-- Table of contents -->
    <div id="print-main-content">
        <div id="jb-print-toc">
            
        </div>
    </div>
</div>

              
                
<div id="searchbox"></div>
                <article class="bd-article">
                  
  <h1>Source code for pybads.bads.bads</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span><span class="w"> </span><span class="nn">copy</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">logging</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">os</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">sys</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">asyncio.log</span><span class="w"> </span><span class="kn">import</span> <span class="n">logger</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">matplotlib.pyplot</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">plt</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">gpyreg.gaussian_process</span><span class="w"> </span><span class="kn">import</span> <span class="n">GP</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">scipy.special</span><span class="w"> </span><span class="kn">import</span> <span class="n">erfc</span><span class="p">,</span> <span class="n">erfcinv</span><span class="p">,</span> <span class="n">gammaincinv</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">scipy.stats</span><span class="w"> </span><span class="kn">import</span> <span class="n">shapiro</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">pybads.acquisition_functions</span><span class="w"> </span><span class="kn">import</span> <span class="n">acq_fcn_lcb</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">pybads.function_logger</span><span class="w"> </span><span class="kn">import</span> <span class="n">FunctionLogger</span><span class="p">,</span> <span class="n">contraints_check</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">pybads.init_functions</span><span class="w"> </span><span class="kn">import</span> <span class="n">init_sobol</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">pybads.poll</span><span class="w"> </span><span class="kn">import</span> <span class="n">poll_mads_2n</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">pybads.search</span><span class="w"> </span><span class="kn">import</span> <span class="n">ESSearchHedge</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">pybads.search.grid_functions</span><span class="w"> </span><span class="kn">import</span> <span class="n">force_to_grid</span><span class="p">,</span> <span class="n">grid_units</span><span class="p">,</span> <span class="n">udist</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">pybads.utils</span><span class="w"> </span><span class="kn">import</span> <span class="n">period_check</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">pybads.utils.iteration_history</span><span class="w"> </span><span class="kn">import</span> <span class="n">IterationHistory</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">pybads.utils.timer</span><span class="w"> </span><span class="kn">import</span> <span class="n">Timer</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">pybads.variable_transformer</span><span class="w"> </span><span class="kn">import</span> <span class="n">VariableTransformer</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">.gaussian_process_train</span><span class="w"> </span><span class="kn">import</span> <span class="p">(</span>
    <span class="n">add_and_update_gp</span><span class="p">,</span>
    <span class="n">init_and_train_gp</span><span class="p">,</span>
    <span class="n">local_gp_fitting</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">.optimize_result</span><span class="w"> </span><span class="kn">import</span> <span class="n">OptimizeResult</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">.options</span><span class="w"> </span><span class="kn">import</span> <span class="n">Options</span>


<div class="viewcode-block" id="BADS">
<a class="viewcode-back" href="../../../api/classes/bads.html#pybads.bads.BADS">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">BADS</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    BADS Constrained optimization using Bayesian Adaptive Direct Search.</span>
<span class="sd">    </span>
<span class="sd">    BADS attempts to solve problems of the form:</span>
<span class="sd">       :math:`\mathtt{argmin}_x  f(x)`  subject to:  lower_bounds :math:`&lt;= x &lt;=` upper_bounds, and optionally :math:`C(x) &lt;= 0`</span>
<span class="sd">                               </span>

<span class="sd">    Initialize a ``PyBADS`` object to set up the optimization problem, then run</span>
<span class="sd">    ``optimize()``. See the examples for more details under the `examples` directory.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    fun : callable</span>
<span class="sd">        A given target ``fun``. ``fun`` accepts input ``x`` and returns a scalar </span>
<span class="sd">        function value of the target evaluated at ``x`` and the noise if provided.</span>
<span class="sd">        In case the target function ``fun`` requires additional data/parameters, </span>
<span class="sd">        they can be handled using an anonymous function.</span>
<span class="sd">        For example: ``fun_for_pybads = lambda x: fun(x, data, extra_params)``, </span>
<span class="sd">        where ``fun`` is the function to optimize, and ``data`` and ``extra_params`` </span>
<span class="sd">        are given in the outer scope.</span>
<span class="sd">    x0 : np.ndarray, optional</span>
<span class="sd">        Starting point for the optimization. If not specified or ``None``, the </span>
<span class="sd">        starting point ``x0`` is uniformly randomly drawn inside the plausible </span>
<span class="sd">        box between ``plausible_lower_bounds`` and ``plausible_upper_bounds`` (see </span>
<span class="sd">        below).</span>
<span class="sd">    lower_bounds, upper_bounds : np.ndarray, optional</span>
<span class="sd">        ``lower_bounds`` (``lb``) and ``upper_bounds`` (``ub``) define a set</span>
<span class="sd">        of strict lower and upper bounds for the coordinate vector, ``x``, so</span>
<span class="sd">        that the unknown function has support on ``lb`` &lt;= ``x`` &lt;= ``ub``.</span>
<span class="sd">        If scalars, the bound is replicated in each dimension. Use</span>
<span class="sd">        ``None`` for ``lb`` and ``ub`` if no bounds exist. Set ``lb[i] = -inf``</span>
<span class="sd">        and ``ub [i] = inf`` if the `i`-th coordinate is unbounded (while</span>
<span class="sd">        other coordinates may be bounded). Note that if ``lb`` and ``ub`` contain</span>
<span class="sd">        unbounded variables, the respective values of ``plb`` and ``pub`` need to</span>
<span class="sd">        be specified (see below). By default ``None``.</span>
<span class="sd">    plausible_lower_bounds, plausible_upper_bounds : np.ndarray, optional</span>
<span class="sd">        Specifies a set of ``plausible_lower_bounds`` (``plb``) and</span>
<span class="sd">        ``plausible_upper_bounds`` (``pub``) such that ``lb`` &lt;= ``plb`` &lt; ``pub`` &lt;= ``ub``.</span>
<span class="sd">        Both ``plb`` and ``pub`` need to be finite. ``plb`` and ``pub`` represent a</span>
<span class="sd">        `plausible` range, which should denote a region where the global minimum</span>
<span class="sd">        is expected to be found. As a rule of thumb, set ``plausible_lower_bounds`` </span>
<span class="sd">        and ``plausible_upper_bounds`` such that there is &gt; 90% probability that </span>
<span class="sd">        the minimum is found within the box (where in doubt, just set </span>
<span class="sd">        ``plb = lb`` and ``pub = ub``).</span>

<span class="sd">    non_box_cons: callable, optional</span>
<span class="sd">        A given non-box constraints function that specifies constraint </span>
<span class="sd">        `violations`, e.g : ``lambda x: np.sum(x.^2,1)&gt;1``</span>

<span class="sd">    options : dict, optional</span>
<span class="sd">        Additional options can be passed as a dict. Please refer to the</span>
<span class="sd">        BADS options page for the default options. If no `options` are</span>
<span class="sd">        passed, the default options are used.</span>
<span class="sd">        To run BADS on a noisy (stochastic) objective function, set </span>
<span class="sd">        ``options[&#39;uncertainty_handling&#39;]`` = ``True``. You can help BADS by </span>
<span class="sd">        providing an estimate of the noise. ``options[&#39;noise_size&#39;] = sigma`` provides a global estimate of the </span>
<span class="sd">        SD of the noise in your problem in a good region of the parameter </span>
<span class="sd">        space. (If not specified, default ``sigma = 1.0``). </span>
<span class="sd">        Alternatively, you can specify the target noise `at each location` </span>
<span class="sd">        with ``options[&#39;specify_target_noise&#39;]`` = ``True``. In this case, </span>
<span class="sd">        ``fun`` is expected to return `two` values, the estimate of the</span>
<span class="sd">        target at ``x`` and an estimate of the SD of the noise at ``x`` </span>
<span class="sd">        (see the examples). </span>
<span class="sd">        If ``options[&#39;uncertainty_handling&#39;]`` is not specified, BADS will </span>
<span class="sd">        determine at runtime if the objective function is noisy.</span>
<span class="sd">        To obtain reproducible results of the optimization, set ``options[&#39;random_seed&#39;]`` </span>
<span class="sd">        to a fixed integer value.</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    ValueError</span>
<span class="sd">        When neither ``x0`` or (``plausible_lower_bounds`` and</span>
<span class="sd">        ``plausible_upper_bounds``) are specified.</span>
<span class="sd">    ValueError</span>
<span class="sd">        When various checks for the bounds (``lower_bounds``, ``upper_bounds``, </span>
<span class="sd">        ``plausible_lower_bounds``, ``plausible_upper_bounds``) of BADS fail.</span>


<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1]  Singh, S. G. &amp; Acerbi, L. (2024). </span>
<span class="sd">            &quot;PyBADS: Fast and robust black-box optimization in Python&quot;.</span>
<span class="sd">            Journal of Open Source Software, 9(94), 5694, https://doi.org/10.21105/joss.05694.</span>

<span class="sd">    .. [2]  Acerbi, L. &amp; Ma, W. J. (2017). &quot;Practical Bayesian</span>
<span class="sd">            Optimization for Model Fitting with Bayesian Adaptive Direct Search&quot;.</span>
<span class="sd">            In `Advances in Neural Information Processing Systems` 30, pages 1834-1844.</span>
<span class="sd">            (arXiv preprint: https://arxiv.org/abs/1705.04405).</span>
<span class="sd">            </span>
<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    For `BADS` usage examples, please look up the Jupyter notebook tutorials</span>
<span class="sd">    in the PyBADS documentation:</span>
<span class="sd">    https://acerbilab.github.io/pybads/examples.html</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">fun</span><span class="p">:</span> <span class="nb">callable</span><span class="p">,</span>
        <span class="n">x0</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">lower_bounds</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">upper_bounds</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">plausible_lower_bounds</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">plausible_upper_bounds</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">non_box_cons</span><span class="p">:</span> <span class="nb">callable</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">gamma_uncertain_interval</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">options</span><span class="p">:</span> <span class="nb">dict</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="c1"># set up root logger (only changes stuff if not initialized yet)</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">basicConfig</span><span class="p">(</span><span class="n">stream</span><span class="o">=</span><span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="s2">&quot;</span><span class="si">%(message)s</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">non_box_cons</span> <span class="o">=</span> <span class="n">non_box_cons</span>

        <span class="c1"># variable to keep track of logging actions</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logging_action</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># Initialize variables and algorithm structures</span>
        <span class="k">if</span> <span class="n">plausible_lower_bounds</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">lower_bounds</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">plausible_lower_bounds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">lower_bounds</span><span class="p">)</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">plausible_upper_bounds</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">upper_bounds</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">plausible_upper_bounds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">upper_bounds</span><span class="p">)</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">x0</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span>
                <span class="n">plausible_lower_bounds</span> <span class="ow">is</span> <span class="kc">None</span>
                <span class="ow">or</span> <span class="n">plausible_upper_bounds</span> <span class="ow">is</span> <span class="kc">None</span>
            <span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
<span class="w">                    </span><span class="sd">&quot;&quot;&quot;bads:UnknownDims If no starting point is</span>
<span class="sd">                 provided, plausible_lower_bounds and plausible_upper_bounds need to be specified.&quot;&quot;&quot;</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">x0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="n">plausible_lower_bounds</span><span class="o">.</span><span class="n">shape</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>

        <span class="n">x0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">x0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">D</span> <span class="o">=</span> <span class="n">x0</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

        <span class="c1"># load basic and advanced options and validate the names</span>
        <span class="n">pybads_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">realpath</span><span class="p">(</span><span class="vm">__file__</span><span class="p">))</span>
        <span class="n">basic_path</span> <span class="o">=</span> <span class="n">pybads_path</span> <span class="o">+</span> <span class="s2">&quot;/option_configs/basic_bads_options.ini&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">options</span> <span class="o">=</span> <span class="n">Options</span><span class="p">(</span>
            <span class="n">basic_path</span><span class="p">,</span>
            <span class="n">evaluation_parameters</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;D&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">D</span><span class="p">},</span>
            <span class="n">user_options</span><span class="o">=</span><span class="n">options</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">advanced_path</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">pybads_path</span> <span class="o">+</span> <span class="s2">&quot;/option_configs/advanced_bads_options.ini&quot;</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="o">.</span><span class="n">load_options_file</span><span class="p">(</span>
            <span class="n">advanced_path</span><span class="p">,</span>
            <span class="n">evaluation_parameters</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;D&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">D</span><span class="p">},</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="o">.</span><span class="n">validate_option_names</span><span class="p">([</span><span class="n">basic_path</span><span class="p">,</span> <span class="n">advanced_path</span><span class="p">])</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="s2">&quot;stobads&quot;</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="s2">&quot;stobads&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="kc">False</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="s2">&quot;stobads&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="c1"># set up random seed</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_init_random_seed_</span><span class="p">()</span>

        <span class="c1"># set up BADS logger</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="s2">&quot;BADS&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">setLevel</span><span class="p">(</span><span class="n">logging</span><span class="o">.</span><span class="n">INFO</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;display&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="s2">&quot;off&quot;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">setLevel</span><span class="p">(</span><span class="n">logging</span><span class="o">.</span><span class="n">WARN</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;display&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="s2">&quot;iter&quot;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">setLevel</span><span class="p">(</span><span class="n">logging</span><span class="o">.</span><span class="n">INFO</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;display&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="s2">&quot;full&quot;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">setLevel</span><span class="p">(</span><span class="n">logging</span><span class="o">.</span><span class="n">DEBUG</span><span class="p">)</span>

        <span class="c1"># Empty lb and ub are Infs</span>
        <span class="k">if</span> <span class="n">lower_bounds</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">lower_bounds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">D</span><span class="p">))</span> <span class="o">*</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span>

        <span class="k">if</span> <span class="n">upper_bounds</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">upper_bounds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">D</span><span class="p">))</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>

        <span class="c1"># Check/fix boundaries and starting points</span>
        <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">x0</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">lower_bounds</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">upper_bounds</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">plausible_lower_bounds</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">plausible_upper_bounds</span><span class="p">,</span>
        <span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bounds_check_</span><span class="p">(</span>
            <span class="n">x0</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span>
            <span class="n">lower_bounds</span><span class="p">,</span>
            <span class="n">upper_bounds</span><span class="p">,</span>
            <span class="n">plausible_lower_bounds</span><span class="p">,</span>
            <span class="n">plausible_upper_bounds</span><span class="p">,</span>
            <span class="n">non_box_cons</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">gamma_uncertain_interval</span> <span class="o">=</span> <span class="n">gamma_uncertain_interval</span>

        <span class="c1"># starting point</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x0</span><span class="p">)):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">x0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span>
                <span class="n">low</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">plausible_lower_bounds</span><span class="p">,</span>
                <span class="n">high</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">plausible_upper_bounds</span><span class="p">,</span>
                <span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">D</span><span class="p">),</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">log</span><span class="p">(</span>
                <span class="mi">25</span><span class="p">,</span>
                <span class="s2">&quot;Initial starting point is invalid or not provided.&quot;</span>
                <span class="o">+</span> <span class="s2">&quot; Initial point randomly sampled uniformly from plausible box</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="c1"># evaluate  starting point non-bound constraint</span>
        <span class="k">if</span> <span class="n">non_box_cons</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">non_box_cons</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x0</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span>
                    <span class="s2">&quot;Initial starting point X0 does not satisfy non-bound constraints (non_box_cons).&quot;</span>
                <span class="p">)</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Initial starting point X0 does not satisfy non-bound constraints (non_box_cons).&quot;</span>
                <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">optim_state</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_init_optim_state_</span><span class="p">()</span>

        <span class="c1"># create and init the function logger</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">function_logger</span> <span class="o">=</span> <span class="n">FunctionLogger</span><span class="p">(</span>
            <span class="n">fun</span><span class="o">=</span><span class="n">fun</span><span class="p">,</span>
            <span class="n">D</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">D</span><span class="p">,</span>
            <span class="n">noise_flag</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">optim_state</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;uncertainty_handling_level&quot;</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span>
            <span class="n">uncertainty_handling_level</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">optim_state</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
                <span class="s2">&quot;uncertainty_handling_level&quot;</span>
            <span class="p">),</span>
            <span class="n">cache_size</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;cache_size&quot;</span><span class="p">),</span>
            <span class="n">variable_transformer</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">var_transf</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">iteration_history</span> <span class="o">=</span> <span class="n">IterationHistory</span><span class="p">(</span>
            <span class="p">[</span>
                <span class="s2">&quot;iter&quot;</span><span class="p">,</span>
                <span class="s2">&quot;func_count&quot;</span><span class="p">,</span>
                <span class="s2">&quot;u&quot;</span><span class="p">,</span>
                <span class="s2">&quot;x&quot;</span><span class="p">,</span>
                <span class="s2">&quot;fval&quot;</span><span class="p">,</span>
                <span class="s2">&quot;fsd&quot;</span><span class="p">,</span>
                <span class="s2">&quot;yval&quot;</span><span class="p">,</span>
                <span class="s2">&quot;ys&quot;</span><span class="p">,</span>
                <span class="s2">&quot;mesh_size&quot;</span><span class="p">,</span>
                <span class="s2">&quot;search_mesh_size&quot;</span><span class="p">,</span>
                <span class="s2">&quot;lcbmax&quot;</span><span class="p">,</span>
                <span class="s2">&quot;gp&quot;</span><span class="p">,</span>
                <span class="s2">&quot;gp_hyp_full&quot;</span><span class="p">,</span>
                <span class="s2">&quot;Ns_gp&quot;</span><span class="p">,</span>
                <span class="s2">&quot;timer&quot;</span><span class="p">,</span>
                <span class="s2">&quot;optim_state&quot;</span><span class="p">,</span>
                <span class="s2">&quot;n_eff&quot;</span><span class="p">,</span>
                <span class="s2">&quot;ntrain&quot;</span><span class="p">,</span>
                <span class="s2">&quot;init_N&quot;</span><span class="p">,</span>
                <span class="s2">&quot;logging_action&quot;</span><span class="p">,</span>
            <span class="p">]</span>
        <span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_bounds_check_</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">x0</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">lower_bounds</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">upper_bounds</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">plausible_lower_bounds</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">plausible_upper_bounds</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">non_box_cons</span><span class="p">:</span> <span class="nb">callable</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Private function for initial checks of the BADS bounds.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">N0</span><span class="p">,</span> <span class="n">D</span> <span class="o">=</span> <span class="n">x0</span><span class="o">.</span><span class="n">shape</span>

        <span class="c1"># Estimation of the plb and pub if any of them is not specified</span>
        <span class="k">if</span> <span class="n">plausible_lower_bounds</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">plausible_upper_bounds</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">N0</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                    <span class="s2">&quot;plausible_lower_bounds and/or plausible_upper_bounds not specified. Estimating&quot;</span>
                    <span class="o">+</span> <span class="s2">&quot;plausible bounds from starting set X0...&quot;</span>
                <span class="p">)</span>
                <span class="n">width</span> <span class="o">=</span> <span class="n">x0</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">-</span> <span class="n">x0</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">plausible_lower_bounds</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">plausible_lower_bounds</span> <span class="o">=</span> <span class="n">x0</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">-</span> <span class="n">width</span> <span class="o">/</span> <span class="n">N0</span>
                    <span class="n">plausible_lower_bounds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span>
                        <span class="n">plausible_lower_bounds</span><span class="p">,</span> <span class="n">lower_bounds</span>
                    <span class="p">)</span>
                <span class="k">if</span> <span class="n">plausible_upper_bounds</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">plausible_upper_bounds</span> <span class="o">=</span> <span class="n">x0</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="n">width</span> <span class="o">/</span> <span class="n">N0</span>
                    <span class="n">plausible_upper_bounds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span>
                        <span class="n">plausible_upper_bounds</span><span class="p">,</span> <span class="n">upper_bounds</span>
                    <span class="p">)</span>

                <span class="n">idx</span> <span class="o">=</span> <span class="n">plausible_lower_bounds</span> <span class="o">==</span> <span class="n">plausible_upper_bounds</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">idx</span><span class="p">):</span>
                    <span class="n">plausible_lower_bounds</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">lower_bounds</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
                    <span class="n">plausible_upper_bounds</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">upper_bounds</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                        <span class="s2">&quot;bads:pbInitFailed: Some plausible bounds could not be &quot;</span>
                        <span class="o">+</span> <span class="s2">&quot;determined from starting set. Using hard upper/lower&quot;</span>
                        <span class="o">+</span> <span class="s2">&quot; bounds for those instead.&quot;</span>
                    <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                    <span class="s2">&quot;bads:pbUnspecified: Plausible lower/upper bounds&quot;</span>
                    <span class="s2">&quot; not specified and X0 is not a valid starting set. &quot;</span>
                    <span class="o">+</span> <span class="s2">&quot;Using hard upper/lower bounds instead.&quot;</span>
                <span class="p">)</span>
                <span class="k">if</span> <span class="n">plausible_lower_bounds</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">plausible_lower_bounds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">lower_bounds</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">plausible_upper_bounds</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">plausible_upper_bounds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">upper_bounds</span><span class="p">)</span>

        <span class="c1"># ensure at least 2d dimensions</span>
        <span class="n">upper_bounds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">upper_bounds</span><span class="p">)</span>
        <span class="n">lower_bounds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">lower_bounds</span><span class="p">)</span>
        <span class="n">plausible_upper_bounds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">plausible_upper_bounds</span><span class="p">)</span>
        <span class="n">plausible_lower_bounds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">plausible_lower_bounds</span><span class="p">)</span>
        <span class="c1"># check that all bounds are row vectors with D elements</span>
        <span class="n">upper_bounds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">upper_bounds</span><span class="p">)</span>
        <span class="n">lower_bounds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">lower_bounds</span><span class="p">)</span>
        <span class="n">plausible_upper_bounds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">plausible_upper_bounds</span><span class="p">)</span>
        <span class="n">plausible_lower_bounds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">plausible_lower_bounds</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="n">lower_bounds</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">D</span><span class="p">)</span>
            <span class="ow">or</span> <span class="n">upper_bounds</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">D</span><span class="p">)</span>
            <span class="ow">or</span> <span class="n">plausible_lower_bounds</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">D</span><span class="p">)</span>
            <span class="ow">or</span> <span class="n">plausible_upper_bounds</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">D</span><span class="p">)</span>
        <span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;&quot;&quot;All input vectors (lower_bounds, upper_bounds,</span>
<span class="s2">                 plausible_lower_bounds, plausible_upper_bounds), if specified,</span>
<span class="s2">                 need to be of the same dimension D=</span><span class="si">{</span><span class="n">D</span><span class="si">}</span><span class="s2"> as the starting point x_0=</span><span class="si">{</span><span class="n">x0</span><span class="si">}</span><span class="s2">.&quot;&quot;&quot;</span>
            <span class="p">)</span>

        <span class="c1"># check that plausible bounds are finite</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">invert</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">plausible_lower_bounds</span><span class="p">)))</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">invert</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">plausible_upper_bounds</span><span class="p">))</span>
        <span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Plausible interval bounds plausible_lower_bounds and plausible_upper_bounds need to be finite.&quot;</span>
            <span class="p">)</span>

        <span class="c1"># Test that all vectors are real-valued</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">invert</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isreal</span><span class="p">(</span><span class="n">x0</span><span class="p">)))</span>
            <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">invert</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isreal</span><span class="p">(</span><span class="n">lower_bounds</span><span class="p">)))</span>
            <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">invert</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isreal</span><span class="p">(</span><span class="n">upper_bounds</span><span class="p">)))</span>
            <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">invert</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isreal</span><span class="p">(</span><span class="n">plausible_lower_bounds</span><span class="p">)))</span>
            <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">invert</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isreal</span><span class="p">(</span><span class="n">plausible_upper_bounds</span><span class="p">)))</span>
        <span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
<span class="w">                </span><span class="sd">&quot;&quot;&quot;All input vectors (x0, lower_bounds, upper_bounds,</span>
<span class="sd">                 plausible_lower_bounds, plausible_upper_bounds), if specified,</span>
<span class="sd">                 need to be real valued.&quot;&quot;&quot;</span>
            <span class="p">)</span>

        <span class="c1"># Fixed variables (all bounds equal) are not supported</span>
        <span class="n">fix_idx</span> <span class="o">=</span> <span class="p">(</span>
            <span class="p">(</span><span class="n">lower_bounds</span> <span class="o">==</span> <span class="n">upper_bounds</span><span class="p">)</span>
            <span class="o">&amp;</span> <span class="p">(</span><span class="n">upper_bounds</span> <span class="o">==</span> <span class="n">plausible_lower_bounds</span><span class="p">)</span>
            <span class="o">&amp;</span> <span class="p">(</span><span class="n">plausible_lower_bounds</span> <span class="o">==</span> <span class="n">plausible_upper_bounds</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">fix_idx</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
<span class="w">                </span><span class="sd">&quot;&quot;&quot;bads:FixedVariables BADS does not support fixed</span>
<span class="sd">            variables. Lower and upper bounds should be different.&quot;&quot;&quot;</span>
            <span class="p">)</span>

        <span class="c1"># Test that plausible bounds are different</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">plausible_lower_bounds</span> <span class="o">==</span> <span class="n">plausible_upper_bounds</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
<span class="w">                </span><span class="sd">&quot;&quot;&quot;bads:MatchingPB:For all variables,</span>
<span class="sd">            plausible lower and upper bounds need to be distinct.&quot;&quot;&quot;</span>
            <span class="p">)</span>

        <span class="c1"># Check that all X0 are inside the bounds</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">x0</span> <span class="o">&lt;</span> <span class="n">lower_bounds</span><span class="p">)</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">x0</span> <span class="o">&gt;</span> <span class="n">upper_bounds</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
<span class="w">                </span><span class="sd">&quot;&quot;&quot;bads:InitialPointsNotInsideBounds: The starting</span>
<span class="sd">                points X0 are not inside the provided hard bounds lower_bounds and upper_bounds.&quot;&quot;&quot;</span>
            <span class="p">)</span>

        <span class="c1"># # Compute &quot;effective&quot; bounds (slightly inside provided hard bounds)</span>
        <span class="n">bounds_range</span> <span class="o">=</span> <span class="n">upper_bounds</span> <span class="o">-</span> <span class="n">lower_bounds</span>
        <span class="n">bounds_range</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isinf</span><span class="p">(</span><span class="n">bounds_range</span><span class="p">)]</span> <span class="o">=</span> <span class="mf">1e3</span>
        <span class="n">scale_factor</span> <span class="o">=</span> <span class="mf">1e-3</span>
        <span class="n">realmin</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">float_info</span><span class="o">.</span><span class="n">min</span>
        <span class="n">LB_eff</span> <span class="o">=</span> <span class="n">lower_bounds</span> <span class="o">+</span> <span class="n">scale_factor</span> <span class="o">*</span> <span class="n">bounds_range</span>
        <span class="n">LB_eff</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">lower_bounds</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">realmin</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">scale_factor</span> <span class="o">*</span> <span class="n">bounds_range</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">lower_bounds</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">realmin</span><span class="p">]</span>
        <span class="p">)</span>
        <span class="n">UB_eff</span> <span class="o">=</span> <span class="n">upper_bounds</span> <span class="o">-</span> <span class="n">scale_factor</span> <span class="o">*</span> <span class="n">bounds_range</span>
        <span class="n">UB_eff</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">upper_bounds</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">realmin</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
            <span class="o">-</span><span class="n">scale_factor</span> <span class="o">*</span> <span class="n">bounds_range</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">upper_bounds</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">realmin</span><span class="p">]</span>
        <span class="p">)</span>
        <span class="c1"># Infinities stay the same</span>
        <span class="n">LB_eff</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isinf</span><span class="p">(</span><span class="n">lower_bounds</span><span class="p">)]</span> <span class="o">=</span> <span class="n">lower_bounds</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isinf</span><span class="p">(</span><span class="n">lower_bounds</span><span class="p">)]</span>
        <span class="n">UB_eff</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isinf</span><span class="p">(</span><span class="n">upper_bounds</span><span class="p">)]</span> <span class="o">=</span> <span class="n">upper_bounds</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isinf</span><span class="p">(</span><span class="n">upper_bounds</span><span class="p">)]</span>

        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">LB_eff</span> <span class="o">&gt;=</span> <span class="n">UB_eff</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
<span class="w">                </span><span class="sd">&quot;&quot;&quot;bads:StrictBoundsTooClose: Hard bounds lower_bounds and upper_bounds</span>
<span class="sd">                are numerically too close. Make them more separate.&quot;&quot;&quot;</span>
            <span class="p">)</span>

        <span class="c1"># Fix when provided X0 are almost on the bounds -- move them inside</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">x0</span> <span class="o">&lt;</span> <span class="n">LB_eff</span><span class="p">)</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">x0</span> <span class="o">&gt;</span> <span class="n">UB_eff</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                <span class="s2">&quot;bads:InitialPointsTooClosePB: The starting points X0 are on &quot;</span>
                <span class="o">+</span> <span class="s2">&quot;or numerically too close to the hard bounds lower_bounds and upper_bounds. &quot;</span>
                <span class="o">+</span> <span class="s2">&quot;Moving the initial points more inside...&quot;</span>
            <span class="p">)</span>
            <span class="n">x0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="n">x0</span><span class="p">,</span> <span class="n">UB_eff</span><span class="p">)),</span> <span class="n">LB_eff</span><span class="p">)</span>

        <span class="c1"># Test order of bounds (permissive)</span>
        <span class="n">ordidx</span> <span class="o">=</span> <span class="p">(</span>
            <span class="p">(</span><span class="n">lower_bounds</span> <span class="o">&lt;=</span> <span class="n">plausible_lower_bounds</span><span class="p">)</span>
            <span class="o">&amp;</span> <span class="p">(</span><span class="n">plausible_lower_bounds</span> <span class="o">&lt;</span> <span class="n">plausible_upper_bounds</span><span class="p">)</span>
            <span class="o">&amp;</span> <span class="p">(</span><span class="n">plausible_upper_bounds</span> <span class="o">&lt;=</span> <span class="n">upper_bounds</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">invert</span><span class="p">(</span><span class="n">ordidx</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
<span class="w">                </span><span class="sd">&quot;&quot;&quot;bads:StrictBounds: For each variable, hard and</span>
<span class="sd">            plausible bounds should respect the ordering lower_bounds &lt; plausible_lower_bounds &lt; plausible_upper_bounds &lt; upper_bounds.&quot;&quot;&quot;</span>
            <span class="p">)</span>

        <span class="c1"># Test that plausible bounds are reasonably separated from hard bounds</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">LB_eff</span> <span class="o">&gt;</span> <span class="n">plausible_lower_bounds</span><span class="p">)</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span>
            <span class="n">plausible_upper_bounds</span> <span class="o">&gt;</span> <span class="n">UB_eff</span>
        <span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                <span class="s2">&quot;bads:TooCloseBounds: For each variable, hard &quot;</span>
                <span class="o">+</span> <span class="s2">&quot;and plausible bounds should not be too close. &quot;</span>
                <span class="o">+</span> <span class="s2">&quot;Moving plausible bounds.&quot;</span>
            <span class="p">)</span>
            <span class="n">plausible_lower_bounds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">plausible_lower_bounds</span><span class="p">,</span> <span class="n">LB_eff</span><span class="p">)</span>
            <span class="n">plausible_upper_bounds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="n">plausible_upper_bounds</span><span class="p">,</span> <span class="n">UB_eff</span><span class="p">)</span>

        <span class="c1"># Check that all X0 are inside the plausible bounds,</span>
        <span class="c1"># move bounds otherwise</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">x0</span> <span class="o">&lt;=</span> <span class="n">LB_eff</span><span class="p">)</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">x0</span> <span class="o">&gt;=</span> <span class="n">UB_eff</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                <span class="s2">&quot;bads:InitialPointsOutsidePB. The starting points X0&quot;</span>
                <span class="o">+</span> <span class="s2">&quot; are not inside the provided plausible bounds (plausible_lower_bounds and plausible_upper_bounds).&quot;</span>
                <span class="o">+</span> <span class="s2">&quot; Expanding the plausible bounds...&quot;</span>
            <span class="p">)</span>
            <span class="n">plausible_lower_bounds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span>
                <span class="n">plausible_lower_bounds</span><span class="p">,</span> <span class="n">x0</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="n">plausible_upper_bounds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span>
                <span class="n">plausible_upper_bounds</span><span class="p">,</span> <span class="n">x0</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="p">)</span>

        <span class="c1"># Test order of bounds</span>
        <span class="n">ordidx</span> <span class="o">=</span> <span class="p">(</span>
            <span class="p">(</span><span class="n">lower_bounds</span> <span class="o">&lt;=</span> <span class="n">plausible_lower_bounds</span><span class="p">)</span>
            <span class="o">&amp;</span> <span class="p">(</span><span class="n">plausible_lower_bounds</span> <span class="o">&lt;</span> <span class="n">plausible_upper_bounds</span><span class="p">)</span>
            <span class="o">&amp;</span> <span class="p">(</span><span class="n">plausible_upper_bounds</span> <span class="o">&lt;=</span> <span class="n">upper_bounds</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">invert</span><span class="p">(</span><span class="n">ordidx</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
<span class="w">                </span><span class="sd">&quot;&quot;&quot;bads:StrictBounds: For each variable, hard and</span>
<span class="sd">            plausible bounds should respect the ordering lower_bounds &lt;= plausible_lower_bounds &lt; plausible_upper_bounds &lt;= upper_bounds.&quot;&quot;&quot;</span>
            <span class="p">)</span>

        <span class="c1"># Check that variables are either bounded or unbounded</span>
        <span class="c1"># (not half-bounded)</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">lower_bounds</span><span class="p">))</span>
            <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">invert</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">upper_bounds</span><span class="p">)))</span>
            <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">invert</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">lower_bounds</span><span class="p">)))</span>
            <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">upper_bounds</span><span class="p">))</span>
        <span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
<span class="w">                </span><span class="sd">&quot;&quot;&quot;bads:HalfBounds: Each variable needs to be unbounded or</span>
<span class="sd">            bounded. Variables bounded only below/above are not supported.&quot;&quot;&quot;</span>
            <span class="p">)</span>

        <span class="c1"># Check non bound constraints</span>
        <span class="k">if</span> <span class="n">non_box_cons</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">non_box_cons</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">plausible_lower_bounds</span><span class="p">,</span> <span class="n">plausible_upper_bounds</span><span class="p">])</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="n">y</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">y</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;bads:NONBCON &quot;</span>
                    <span class="o">+</span> <span class="s2">&quot;NONBCON should be a function that takes a matrix X as input&quot;</span>
                    <span class="o">+</span> <span class="s2">&quot; and returns a column vector of bound violations.&quot;</span>
                <span class="p">)</span>

        <span class="c1"># Gentle warning for infinite bounds</span>
        <span class="n">ninfs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isinf</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">lower_bounds</span><span class="p">,</span> <span class="n">upper_bounds</span><span class="p">])))</span>
        <span class="k">if</span> <span class="n">ninfs</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">ninfs</span> <span class="o">==</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">D</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                    <span class="s2">&quot;Detected fully unconstrained optimization.&quot;</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Detected </span><span class="si">{</span><span class="n">ninfs</span><span class="si">}</span><span class="s2"> infinite bound(s).&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="p">(</span>
            <span class="n">x0</span><span class="p">,</span>
            <span class="n">lower_bounds</span><span class="p">,</span>
            <span class="n">upper_bounds</span><span class="p">,</span>
            <span class="n">plausible_lower_bounds</span><span class="p">,</span>
            <span class="n">plausible_upper_bounds</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_init_optim_state_</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A private function to initialize the optim_state dict that contains information about BADS variables.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Record starting points (original coordinates)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="s2">&quot;f_vals&quot;</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">y_orig</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;f_vals&quot;</span><span class="p">))</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">y_orig</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">y_orig</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">x0</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x0</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">y_orig</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
<span class="w">                    </span><span class="sd">&quot;&quot;&quot;bads:MismatchedStartingInputs The number of</span>
<span class="sd">                points in X0 and of their function values as specified in</span>
<span class="sd">                self.options.[&#39;f_vals&#39;] are not the same.&quot;&quot;&quot;</span>
                <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">y_orig</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">x0</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>

        <span class="n">optim_state</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="n">optim_state</span><span class="p">[</span><span class="s2">&quot;random_seed&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_random_seed</span>
        <span class="n">optim_state</span><span class="p">[</span><span class="s2">&quot;cache&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="n">optim_state</span><span class="p">[</span><span class="s2">&quot;cache&quot;</span><span class="p">][</span><span class="s2">&quot;x_orig&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">x0</span>
        <span class="n">optim_state</span><span class="p">[</span><span class="s2">&quot;cache&quot;</span><span class="p">][</span><span class="s2">&quot;y_orig&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">y_orig</span>
        <span class="n">optim_state</span><span class="p">[</span><span class="s2">&quot;last_re_eval&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span>

        <span class="c1"># Does the starting cache contain function values?</span>
        <span class="n">optim_state</span><span class="p">[</span><span class="s2">&quot;cache_active&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">optim_state</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;cache&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;y_orig&quot;</span><span class="p">))</span>
        <span class="p">)</span>

        <span class="c1"># Grid parameters</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mesh_size_integer</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[</span>
            <span class="s2">&quot;init_mesh_size_integer&quot;</span>
        <span class="p">]</span>  <span class="c1"># Mesh size in log base units</span>
        <span class="n">optim_state</span><span class="p">[</span><span class="s2">&quot;search_size_integer&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span>
            <span class="mi">0</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mesh_size_integer</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;search_grid_multiplier&quot;</span><span class="p">)</span>
            <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;search_grid_number&quot;</span><span class="p">),</span>
        <span class="p">)</span>
        <span class="n">optim_state</span><span class="p">[</span><span class="s2">&quot;mesh_size&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
            <span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;poll_mesh_multiplier&quot;</span><span class="p">))</span>
            <span class="o">**</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh_size_integer</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mesh_size</span> <span class="o">=</span> <span class="n">optim_state</span><span class="p">[</span><span class="s2">&quot;mesh_size&quot;</span><span class="p">]</span>
        <span class="n">optim_state</span><span class="p">[</span><span class="s2">&quot;search_mesh_size&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
            <span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;poll_mesh_multiplier&quot;</span><span class="p">))</span>
            <span class="o">**</span> <span class="n">optim_state</span><span class="p">[</span><span class="s2">&quot;search_size_integer&quot;</span><span class="p">]</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">search_mesh_size</span> <span class="o">=</span> <span class="n">optim_state</span><span class="p">[</span><span class="s2">&quot;search_mesh_size&quot;</span><span class="p">]</span>
        <span class="n">optim_state</span><span class="p">[</span><span class="s2">&quot;scale&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span>

        <span class="c1"># Check if periodic_vars is not None and raise error, since it is not yet supported</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="s2">&quot;periodic_vars&quot;</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Periodic variables are not yet supported. Please set periodic_vars to None.&quot;</span>
            <span class="p">)</span>

        <span class="c1"># Compute transformation of variables</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="s2">&quot;nonlinear_scaling&quot;</span><span class="p">]:</span>
            <span class="n">logflag</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">D</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
            <span class="n">periodic_vars</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="s2">&quot;periodic_vars&quot;</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">periodic_vars</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">periodic_vars</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">logflag</span><span class="p">[</span>
                    <span class="p">:,</span> <span class="n">periodic_vars</span>
                <span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># Never transform periodic variables</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">logflag</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">D</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">var_transf</span> <span class="o">=</span> <span class="n">VariableTransformer</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">D</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">lower_bounds</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">upper_bounds</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">plausible_lower_bounds</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">plausible_upper_bounds</span><span class="p">,</span>
            <span class="n">logflag</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="c1"># optim_state[&quot;variables_trans&quot;] = var_transf</span>

        <span class="c1"># Update the bounds with the new transformed bounds</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lower_bounds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">var_transf</span><span class="o">.</span><span class="n">lb</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">upper_bounds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">var_transf</span><span class="o">.</span><span class="n">ub</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">optim_state</span><span class="p">[</span><span class="s2">&quot;lb&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lower_bounds</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">optim_state</span><span class="p">[</span><span class="s2">&quot;ub&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">upper_bounds</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">plausible_lower_bounds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">var_transf</span><span class="o">.</span><span class="n">plb</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">plausible_upper_bounds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">var_transf</span><span class="o">.</span><span class="n">pub</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">optim_state</span><span class="p">[</span><span class="s2">&quot;pub&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">plausible_lower_bounds</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">optim_state</span><span class="p">[</span><span class="s2">&quot;plb&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">plausible_upper_bounds</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="n">optim_state</span><span class="p">[</span><span class="s2">&quot;lb_orig&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">var_transf</span><span class="o">.</span><span class="n">orig_lb</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">optim_state</span><span class="p">[</span><span class="s2">&quot;ub_orig&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">var_transf</span><span class="o">.</span><span class="n">orig_ub</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">optim_state</span><span class="p">[</span><span class="s2">&quot;plb_orig&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">var_transf</span><span class="o">.</span><span class="n">orig_plb</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">optim_state</span><span class="p">[</span><span class="s2">&quot;pub_orig&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">var_transf</span><span class="o">.</span><span class="n">orig_pub</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="c1"># Bounds for search mesh</span>
        <span class="n">lb_search</span> <span class="o">=</span> <span class="n">force_to_grid</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">lower_bounds</span><span class="p">,</span> <span class="n">optim_state</span><span class="p">[</span><span class="s2">&quot;search_mesh_size&quot;</span><span class="p">]</span>
        <span class="p">)</span>
        <span class="n">lb_search</span><span class="p">[</span><span class="n">lb_search</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">lower_bounds</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">lb_search</span><span class="p">[</span><span class="n">lb_search</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">lower_bounds</span><span class="p">]</span>
            <span class="o">+</span> <span class="n">optim_state</span><span class="p">[</span><span class="s2">&quot;search_mesh_size&quot;</span><span class="p">]</span>
        <span class="p">)</span>
        <span class="n">optim_state</span><span class="p">[</span><span class="s2">&quot;lb_search&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">lb_search</span>
        <span class="n">ub_search</span> <span class="o">=</span> <span class="n">force_to_grid</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">upper_bounds</span><span class="p">,</span> <span class="n">optim_state</span><span class="p">[</span><span class="s2">&quot;search_mesh_size&quot;</span><span class="p">]</span>
        <span class="p">)</span>
        <span class="n">ub_search</span><span class="p">[</span><span class="n">ub_search</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">upper_bounds</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">ub_search</span><span class="p">[</span><span class="n">ub_search</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">upper_bounds</span><span class="p">]</span>
            <span class="o">-</span> <span class="n">optim_state</span><span class="p">[</span><span class="s2">&quot;search_mesh_size&quot;</span><span class="p">]</span>
        <span class="p">)</span>
        <span class="n">optim_state</span><span class="p">[</span><span class="s2">&quot;ub_search&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ub_search</span>
        
        <span class="c1"># Starting point in grid coordinates, gridization</span>
        <span class="n">u0</span> <span class="o">=</span> <span class="n">force_to_grid</span><span class="p">(</span>
            <span class="n">grid_units</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">var_transf</span><span class="p">,</span> <span class="n">optim_state</span><span class="p">[</span><span class="s2">&quot;scale&quot;</span><span class="p">]),</span>
            <span class="n">optim_state</span><span class="p">[</span><span class="s2">&quot;search_mesh_size&quot;</span><span class="p">],</span>
        <span class="p">)</span>

        <span class="c1"># Adjust points that fall outside bounds due to gridization</span>
        <span class="n">u0</span><span class="p">[</span><span class="n">u0</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">lower_bounds</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">u0</span><span class="p">[</span><span class="n">u0</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">lower_bounds</span><span class="p">]</span> <span class="o">+</span> <span class="n">optim_state</span><span class="p">[</span><span class="s2">&quot;search_mesh_size&quot;</span><span class="p">]</span>
        <span class="p">)</span>
        <span class="n">u0</span><span class="p">[</span><span class="n">u0</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">upper_bounds</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">u0</span><span class="p">[</span><span class="n">u0</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">upper_bounds</span><span class="p">]</span> <span class="o">-</span> <span class="n">optim_state</span><span class="p">[</span><span class="s2">&quot;search_mesh_size&quot;</span><span class="p">]</span>
        <span class="p">)</span>
        
        <span class="c1"># Check that the gridized points satisfies the non-bound constraints</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">non_box_cons</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> \
            <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">non_box_cons</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">var_transf</span><span class="o">.</span><span class="n">inverse_transf</span><span class="p">(</span><span class="n">u0</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span>
<span class="w">                </span><span class="sd">&quot;&quot;&quot;Initial starting point X0 does no longer satisfy non-bound constraint after being fit into the mesh grid.&quot;&quot;&quot;</span>
            <span class="p">)</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
<span class="w">                </span><span class="sd">&quot;&quot;&quot;Initial starting point X0 does no longer satisfy non-bound constraint after being fit into the mesh grid.&quot;&quot;&quot;</span>
            <span class="p">)</span>
        
        <span class="n">optim_state</span><span class="p">[</span><span class="s2">&quot;u&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">u0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">u</span> <span class="o">=</span> <span class="n">u0</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="c1"># Test starting point u0 is within bounds</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">u0</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">upper_bounds</span><span class="p">)</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">u0</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">lower_bounds</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span>
                <span class="s2">&quot;Initial starting point u0 is not within the hard bounds lower_bounds and upper_bounds&quot;</span>
            <span class="p">)</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
<span class="w">                </span><span class="sd">&quot;&quot;&quot;bads:Initpoint: Initial starting point u0 is not within the hard bounds lower_bounds and upper_bounds&quot;&quot;&quot;</span>
            <span class="p">)</span>

        <span class="c1"># Report variable transformation</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">var_transf</span><span class="o">.</span><span class="n">apply_log_t</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Variables (index) internally transformed to log coordinates: </span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">var_transf</span><span class="o">.</span><span class="n">apply_log_t</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>

        <span class="c1"># Put tol_mesh on space</span>
        <span class="n">optim_state</span><span class="p">[</span><span class="s2">&quot;tol_mesh&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[</span>
            <span class="s2">&quot;poll_mesh_multiplier&quot;</span>
        <span class="p">]</span> <span class="o">**</span> <span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="s2">&quot;tol_mesh&quot;</span><span class="p">])</span>
            <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="s2">&quot;poll_mesh_multiplier&quot;</span><span class="p">])</span>
        <span class="p">)</span>

        <span class="c1"># Periodic variables</span>
        <span class="n">idx_periodic_vars</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="s2">&quot;periodic_vars&quot;</span><span class="p">]</span>
        <span class="n">periodic_vars</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">D</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">bool</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">idx_periodic_vars</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">periodic_vars</span><span class="p">[:,</span> <span class="n">idx_periodic_vars</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">finite_periodic_vars</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lower_bounds</span><span class="p">[:,</span> <span class="n">idx_periodic_vars</span><span class="p">])</span>
            <span class="p">)</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">upper_bounds</span><span class="p">[:,</span> <span class="n">idx_periodic_vars</span><span class="p">]))</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">finite_periodic_vars</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;bads:InitOptimState:Periodic variables need to have finite lower and upper bounds.&quot;</span>
                <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Variables (index) defined with periodic boundaries: </span><span class="si">{</span><span class="n">idx_periodic_vars</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>
        <span class="n">optim_state</span><span class="p">[</span><span class="s2">&quot;periodic_vars&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">periodic_vars</span>

        <span class="c1"># Setup covariance information (unused)</span>

        <span class="c1"># Import prior function evaluations</span>
        <span class="n">fun_values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="s2">&quot;fun_values&quot;</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">fun_values</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">fun_values</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="s2">&quot;X&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">fun_values</span> <span class="ow">or</span> <span class="s2">&quot;Y&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">fun_values</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
<span class="w">                    </span><span class="sd">&quot;&quot;&quot;bads:fun_values: The &#39;fun_values&#39; field in options need to have X and Y fields (respectively, inputs and their function values)&quot;&quot;&quot;</span>
                <span class="p">)</span>

            <span class="n">X</span> <span class="o">=</span> <span class="n">fun_values</span><span class="p">[</span><span class="s2">&quot;X&quot;</span><span class="p">]</span>
            <span class="n">Y</span> <span class="o">=</span> <span class="n">fun_values</span><span class="p">[</span><span class="s2">&quot;Y&quot;</span><span class="p">]</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">X</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">Y</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;X and Y arrays in the options[&#39;fun_values&#39;] need to have the same number of rows (each row is a tested point).&quot;</span>
                <span class="p">)</span>
            <span class="k">if</span> <span class="p">(</span>
                <span class="p">(</span><span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">X</span><span class="p">)))</span>
                <span class="ow">or</span> <span class="p">(</span><span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">Y</span><span class="p">)))</span>
                <span class="ow">or</span> <span class="p">(</span><span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isreal</span><span class="p">(</span><span class="n">X</span><span class="p">))</span>
                <span class="ow">or</span> <span class="p">(</span><span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isreal</span><span class="p">(</span><span class="n">Y</span><span class="p">))</span>
            <span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;X and Y arrays need to be finite and real-valued&quot;</span>
                <span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">X</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">D</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;X should be a matrix of tested points with the same dimensionality as X0 (one input point per row).&quot;</span>
                <span class="p">)</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">Y</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">Y</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Y should be a vertical nd-array (, 1) of function values (one function value per row).&quot;</span>
                <span class="p">)</span>

            <span class="n">S</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">if</span> <span class="s2">&quot;S&quot;</span> <span class="ow">in</span> <span class="n">fun_values</span><span class="p">:</span>
                <span class="n">S</span> <span class="o">=</span> <span class="n">fun_values</span><span class="p">[</span><span class="s2">&quot;S&quot;</span><span class="p">]</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">S</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">Y</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="s2">&quot;X, Y, and S arrays in the options[&#39;fun_values&#39;] need to have the same number of rows (each row is a tested point).&quot;</span>
                    <span class="p">)</span>
                <span class="n">S</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">S</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">S</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">S</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="s2">&quot;S should be a vertical nd-array (, 1) of estimated function SD values (one SD per row).&quot;</span>
                    <span class="p">)</span>

            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">()):</span>
                <span class="k">if</span> <span class="n">S</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">function_logger</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">Y</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">function_logger</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">Y</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">S</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

        <span class="c1"># Other variables initializations</span>
        <span class="n">optim_state</span><span class="p">[</span><span class="s2">&quot;search_factor&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">optim_state</span><span class="p">[</span><span class="s2">&quot;sd_level&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="s2">&quot;incumbent_sigma_multiplier&quot;</span><span class="p">]</span>
        <span class="n">optim_state</span><span class="p">[</span><span class="s2">&quot;search_count&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[</span>
            <span class="s2">&quot;search_n_try&quot;</span>
        <span class="p">]</span>  <span class="c1"># Skip search at first iteration</span>
        <span class="n">optim_state</span><span class="p">[</span><span class="s2">&quot;lastreeval&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span>
        <span class="c1"># Last time function values were re-evaluated</span>
        <span class="n">optim_state</span><span class="p">[</span><span class="s2">&quot;lastfitgp&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span>
        <span class="c1"># Last fcn evaluation for which the gp was trained</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mesh_overflows</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="c1"># Number of attempted mesh expansions when already at maximum size</span>

        <span class="c1"># List of points at the end of each iteration</span>
        <span class="n">optim_state</span><span class="p">[</span><span class="s2">&quot;iterlist&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="n">optim_state</span><span class="p">[</span><span class="s2">&quot;iterlist&quot;</span><span class="p">][</span><span class="s2">&quot;u&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">optim_state</span><span class="p">[</span><span class="s2">&quot;iterlist&quot;</span><span class="p">][</span><span class="s2">&quot;fval&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">optim_state</span><span class="p">[</span><span class="s2">&quot;iterlist&quot;</span><span class="p">][</span><span class="s2">&quot;fsd&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">optim_state</span><span class="p">[</span><span class="s2">&quot;iterlist&quot;</span><span class="p">][</span><span class="s2">&quot;fhyp&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># optim_state[&#39;es&#39;] = es_update(es_mu, es_lambda)</span>

        <span class="c1"># Hedge struct</span>
        <span class="n">optim_state</span><span class="p">[</span><span class="s2">&quot;search_hedge&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>

        <span class="c1"># Before first iteration</span>
        <span class="c1"># Iterations are from 0 onwards in optimize so we should have -1</span>
        <span class="n">optim_state</span><span class="p">[</span><span class="s2">&quot;iter&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>

        <span class="c1"># Copy maximum number of fcn. evaluations,</span>
        <span class="c1"># used by some acquisition fcns.</span>
        <span class="n">optim_state</span><span class="p">[</span><span class="s2">&quot;max_fun_evals&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;max_fun_evals&quot;</span><span class="p">)</span>

        <span class="c1"># Deal with user specified target noise</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="s2">&quot;specify_target_noise&quot;</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="s2">&quot;specify_target_noise&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="k">if</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="s2">&quot;specify_target_noise&quot;</span><span class="p">]</span>
            <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="s2">&quot;uncertainty_handling&quot;</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span>
        <span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="s2">&quot;uncertainty_handling&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="k">if</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="s2">&quot;specify_target_noise&quot;</span><span class="p">]</span>
            <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="s2">&quot;uncertainty_handling&quot;</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
            <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="s2">&quot;uncertainty_handling&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="kc">False</span>
        <span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;If options[&#39;specify_target_noise&#39;] is True, options[&#39;uncertainty_handling&#39;] should be True as well. </span><span class="se">\</span>
<span class="s2">                                Leave options[&#39;uncertainty_handling&#39;] empty or set it to True to avoid this error.&quot;</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="s2">&quot;specify_target_noise&quot;</span><span class="p">]</span>
            <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="s2">&quot;noise_size&quot;</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
            <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="s2">&quot;noise_size&quot;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="s2">&quot;If options[&#39;specify_target_noise&#39;] is True, options[&#39;noise_size&#39;] is ignored. </span><span class="se">\</span>
<span class="s2">                Leave options[&#39;noise_size&#39;] empty or set it to 0 to silence this warning.&quot;</span>
            <span class="p">)</span>

        <span class="c1"># Set uncertainty handling level</span>
        <span class="c1"># (0: none; 1: unknown noise level; 2: user-provided noise)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;specify_target_noise&quot;</span><span class="p">):</span>
            <span class="n">optim_state</span><span class="p">[</span><span class="s2">&quot;uncertainty_handling_level&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span>
        <span class="k">elif</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="s2">&quot;uncertainty_handling&quot;</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
            <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="s2">&quot;uncertainty_handling&quot;</span><span class="p">]</span>
        <span class="p">):</span>
            <span class="n">optim_state</span><span class="p">[</span><span class="s2">&quot;uncertainty_handling_level&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">optim_state</span><span class="p">[</span><span class="s2">&quot;uncertainty_handling_level&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># Empty hedge struct for acquisition functions</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;acq_hedge&quot;</span><span class="p">):</span>
            <span class="n">optim_state</span><span class="p">[</span><span class="s2">&quot;acq_hedge&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>

        <span class="c1"># List of points at the end of each iteration</span>
        <span class="n">optim_state</span><span class="p">[</span><span class="s2">&quot;iterlist&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="n">optim_state</span><span class="p">[</span><span class="s2">&quot;iterlist&quot;</span><span class="p">][</span><span class="s2">&quot;u&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">optim_state</span><span class="p">[</span><span class="s2">&quot;iterlist&quot;</span><span class="p">][</span><span class="s2">&quot;fval&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">optim_state</span><span class="p">[</span><span class="s2">&quot;iterlist&quot;</span><span class="p">][</span><span class="s2">&quot;fsd&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">optim_state</span><span class="p">[</span><span class="s2">&quot;iterlist&quot;</span><span class="p">][</span><span class="s2">&quot;fhyp&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># Initialize Gaussian process settings</span>
        <span class="c1"># Squared exponential kernel with separate length scales</span>
        <span class="n">optim_state</span><span class="p">[</span><span class="s2">&quot;gp_cov_fun&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

        <span class="k">if</span> <span class="n">optim_state</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;uncertainty_handling_level&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># Observation noise for stability</span>
            <span class="n">optim_state</span><span class="p">[</span><span class="s2">&quot;gp_noisefun&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">optim_state</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;uncertainty_handling_level&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># Infer noise</span>
            <span class="n">optim_state</span><span class="p">[</span><span class="s2">&quot;gp_noisefun&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">optim_state</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;uncertainty_handling_level&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="c1"># Provided heteroskedastic noise</span>
            <span class="n">optim_state</span><span class="p">[</span><span class="s2">&quot;gp_noisefun&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>

        <span class="k">if</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;noise_shaping&quot;</span><span class="p">)</span>
            <span class="ow">and</span> <span class="n">optim_state</span><span class="p">[</span><span class="s2">&quot;gp_noisefun&quot;</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span>
        <span class="p">):</span>
            <span class="n">optim_state</span><span class="p">[</span><span class="s2">&quot;gp_noisefun&quot;</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

        <span class="n">optim_state</span><span class="p">[</span><span class="s2">&quot;gp_mean_fun&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;gp_mean_fun&quot;</span><span class="p">)</span>
        <span class="n">valid_gp_mean_funs</span> <span class="o">=</span> <span class="p">[</span>
            <span class="s2">&quot;zero&quot;</span><span class="p">,</span>
            <span class="s2">&quot;const&quot;</span><span class="p">,</span>
            <span class="s2">&quot;negquad&quot;</span><span class="p">,</span>
            <span class="s2">&quot;se&quot;</span><span class="p">,</span>
            <span class="s2">&quot;negquadse&quot;</span><span class="p">,</span>
            <span class="s2">&quot;negquadfixiso&quot;</span><span class="p">,</span>
            <span class="s2">&quot;negquadfix&quot;</span><span class="p">,</span>
            <span class="s2">&quot;negquadsefix&quot;</span><span class="p">,</span>
            <span class="s2">&quot;negquadonly&quot;</span><span class="p">,</span>
            <span class="s2">&quot;negquadfixonly&quot;</span><span class="p">,</span>
            <span class="s2">&quot;negquadlinonly&quot;</span><span class="p">,</span>
            <span class="s2">&quot;negquadmix&quot;</span><span class="p">,</span>
        <span class="p">]</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">optim_state</span><span class="p">[</span><span class="s2">&quot;gp_mean_fun&quot;</span><span class="p">]</span> <span class="ow">in</span> <span class="n">valid_gp_mean_funs</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
<span class="w">                </span><span class="sd">&quot;&quot;&quot;bads:UnknownGPmean:Unknown/unsupported GP mean</span>
<span class="sd">            function. Supported mean functions are zero, const,</span>
<span class="sd">            egquad, and se&quot;&quot;&quot;</span>
            <span class="p">)</span>
        <span class="n">optim_state</span><span class="p">[</span><span class="s2">&quot;int_meanfun&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;gpintmeanfun&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">optim_state</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_init_random_seed_</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># set random seed if provided</span>
        <span class="k">if</span> <span class="s2">&quot;random_seed&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span> <span class="ow">and</span> \
            <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="s2">&quot;random_seed&quot;</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># set random seed to numpy and consequently to scipy (scipy uses the same number generator)</span>
            <span class="n">random_seed</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="s2">&quot;random_seed&quot;</span><span class="p">])</span>
            <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="n">random_seed</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">random_seed</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_random_seed</span> <span class="o">=</span> <span class="n">random_seed</span>
        <span class="k">return</span> <span class="n">random_seed</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_init_mesh_</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A private function to initialize the mesh frame and the optimization problem.</span>
<span class="sd">        It evaluates the initial points, which includes the starting point and the generated point retrieved from a sobol sequence generating method.</span>
<span class="sd">        The init_mesh also assess if the target function is stochastic and set the parameter of BADS for handling stochastic targets.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Evaluate starting point and initial mesh, determine if function is noisy</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">yval</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">fsd</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">function_logger</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">u</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">fsd</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fsd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fval</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">yval</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">optim_state</span><span class="p">[</span><span class="s2">&quot;fval&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fval</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">optim_state</span><span class="p">[</span><span class="s2">&quot;yval&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">yval</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">optim_state</span><span class="p">[</span><span class="s2">&quot;uncertainty_handling_level&quot;</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># test if the function is noisy</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logging_action</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;Uncertainty test&quot;</span><span class="p">)</span>
            <span class="n">yval_bis</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">function_logger</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">u</span><span class="p">,</span> <span class="n">record_duplicate_data</span><span class="o">=</span><span class="kc">False</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">yval</span> <span class="o">-</span> <span class="n">yval_bis</span><span class="p">)</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="s2">&quot;tol_noise&quot;</span><span class="p">]:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">optim_state</span><span class="p">[</span><span class="s2">&quot;uncertainty_handling_level&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logging_action</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;Uncertainty test&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logging_action</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">optim_state</span><span class="p">[</span><span class="s2">&quot;uncertainty_handling_level&quot;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="s2">&quot;specify_target_noise&quot;</span><span class="p">]:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                    <span class="s2">&quot;Beginning optimization of a STOCHASTIC objective function (specified noise)</span><span class="se">\n</span><span class="s2">&quot;</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                    <span class="s2">&quot;Beginning optimization of a STOCHASTIC objective function</span><span class="se">\n</span><span class="s2">&quot;</span>
                <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                <span class="s2">&quot;Beginning optimization of a DETERMINISTIC objective function</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="p">)</span>

        <span class="c1"># Only one function evaluation</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="s2">&quot;max_fun_evals&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">is_finished</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">return</span>

        <span class="c1"># If dealing with a noisy function, use a large initial mesh</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">optim_state</span><span class="p">[</span><span class="s2">&quot;uncertainty_handling_level&quot;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="s2">&quot;fun_eval_start&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="s2">&quot;fun_eval_start&quot;</span><span class="p">]),</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="s2">&quot;max_fun_evals&quot;</span><span class="p">],</span>
            <span class="p">)</span>

        <span class="c1"># set up strings for logging of the iteration</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">display_format</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_setup_logging_display_format</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_log_column_headers</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_display_function_log_</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="s2">&quot;fun_eval_start&quot;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># Evaluate initial points but not more than options[&#39;max_fun_evals&#39;]</span>
            <span class="n">fun_eval_start</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="s2">&quot;fun_eval_start&quot;</span><span class="p">],</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="s2">&quot;max_fun_evals&quot;</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="s2">&quot;init_fun&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;init_sobol&quot;</span><span class="p">:</span>

                <span class="n">u1</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">init_sobol</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">u</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">lower_bounds</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">upper_bounds</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">plausible_lower_bounds</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">plausible_upper_bounds</span><span class="p">,</span>
                    <span class="n">fun_eval_start</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="c1"># enforce periodicity TODO function</span>
                <span class="n">u1</span> <span class="o">=</span> <span class="n">period_check</span><span class="p">(</span>
                    <span class="n">u1</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">lower_bounds</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">upper_bounds</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="s2">&quot;periodic_vars&quot;</span><span class="p">],</span>
                <span class="p">)</span>

                <span class="c1"># Force points to be in the search grid.</span>
                <span class="n">u1</span> <span class="o">=</span> <span class="n">force_to_grid</span><span class="p">(</span><span class="n">u1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">optim_state</span><span class="p">[</span><span class="s2">&quot;search_mesh_size&quot;</span><span class="p">])</span>

                <span class="c1"># Remove already evaluated or unfeasible points from search set</span>
                <span class="n">u1</span> <span class="o">=</span> <span class="n">contraints_check</span><span class="p">(</span>
                    <span class="n">u1</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">optim_state</span><span class="p">[</span><span class="s2">&quot;lb_search&quot;</span><span class="p">],</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">optim_state</span><span class="p">[</span><span class="s2">&quot;ub_search&quot;</span><span class="p">],</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">optim_state</span><span class="p">[</span><span class="s2">&quot;tol_mesh&quot;</span><span class="p">],</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">function_logger</span><span class="p">,</span>
                    <span class="kc">True</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">non_box_cons</span><span class="p">,</span>
                <span class="p">)</span>

                <span class="k">for</span> <span class="n">u_idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">u1</span><span class="p">)):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">function_logger</span><span class="p">(</span><span class="n">u1</span><span class="p">[</span><span class="n">u_idx</span><span class="p">])</span>

                <span class="n">idx_yval</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">function_logger</span><span class="o">.</span><span class="n">Y</span><span class="p">[:</span> <span class="bp">self</span><span class="o">.</span><span class="n">function_logger</span><span class="o">.</span><span class="n">Xn</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
                <span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">u</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">function_logger</span><span class="o">.</span><span class="n">X</span><span class="p">[</span><span class="n">idx_yval</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">yval</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">function_logger</span><span class="o">.</span><span class="n">Y</span><span class="p">[</span><span class="n">idx_yval</span><span class="p">]</span><span class="o">.</span><span class="n">item</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">fval</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">yval</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logging_action</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;Initial points&quot;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_display_function_log_</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;Initial mesh&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;bads:init_fun:Initialization function not implemented yet&quot;</span>
                <span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">yval</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;init mesh: Cannot find valid starting point.&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">optim_state</span><span class="p">[</span><span class="s2">&quot;fval&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fval</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">optim_state</span><span class="p">[</span><span class="s2">&quot;yval&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">yval</span>

        <span class="c1"># Save the efffective number of initial starting points, which can match with options[&#39;fun_eval_start&#39;]</span>
        <span class="c1"># but it might be different for example when considering a noisy target function OR when applying a non-box-contraint function.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">optim_state</span><span class="p">[</span><span class="s2">&quot;eff_starting_points&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">function_logger</span><span class="o">.</span><span class="n">Xn</span> <span class="o">+</span> <span class="mi">1</span>

        <span class="k">return</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_init_optimization_</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A private function initialize the optimization problem.</span>
<span class="sd">        It calls the init_mesh, sets the option configurations required by BADS, and initializes the Guassian Process (GP)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">gp</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reset_gp</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">hyp_dict</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="c1"># set random seed if provided</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">optim_state</span><span class="p">[</span><span class="s2">&quot;random_seed&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_init_random_seed_</span><span class="p">()</span>
        
        <span class="c1"># Evaluate starting point and initial mesh,</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_init_mesh_</span><span class="p">()</span>

        <span class="c1"># Change options for uncertainty handling</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">optim_state</span><span class="p">[</span><span class="s2">&quot;uncertainty_handling_level&quot;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="s2">&quot;tol_stall_iters&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="s2">&quot;tol_stall_iters&quot;</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="s2">&quot;n_train_max&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">200</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="s2">&quot;n_train_max&quot;</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="s2">&quot;n_train_min&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="s2">&quot;n_train_min&quot;</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="s2">&quot;mesh_overflow_warning&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                <span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="s2">&quot;mesh_overflow_warning&quot;</span><span class="p">]</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="s2">&quot;min_failed_poll_steps&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="s2">&quot;mesh_noise_multiplier&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="s2">&quot;noise_size&quot;</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="s2">&quot;noise_size&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="s2">&quot;noise_size&quot;</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span>
            <span class="p">):</span>  <span class="c1"># ensure the noise_size is a scalar</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="s2">&quot;noise_size&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="s2">&quot;noise_size&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">item</span><span class="p">()</span>

            <span class="c1"># Keep some function evaluations for the final resampling</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="s2">&quot;noise_final_samples&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="s2">&quot;noise_final_samples&quot;</span><span class="p">],</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="s2">&quot;max_fun_evals&quot;</span><span class="p">]</span>
                <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">function_logger</span><span class="o">.</span><span class="n">func_count</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="s2">&quot;max_fun_evals&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="s2">&quot;max_fun_evals&quot;</span><span class="p">]</span>
                <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="s2">&quot;noise_final_samples&quot;</span><span class="p">]</span>
            <span class="p">)</span>

            <span class="c1"># Specify the standard deviation of the function values</span>
            <span class="c1"># It corresponds to specify target noise of Matlab</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">optim_state</span><span class="p">[</span><span class="s2">&quot;uncertainty_handling_level&quot;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">idx_min_y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">function_logger</span><span class="o">.</span><span class="n">Y</span><span class="p">[:</span> <span class="bp">self</span><span class="o">.</span><span class="n">function_logger</span><span class="o">.</span><span class="n">Xn</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
                <span class="p">)</span><span class="o">.</span><span class="n">item</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">fsd</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">function_logger</span><span class="o">.</span><span class="n">S</span><span class="p">[</span><span class="n">idx_min_y</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">fsd</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fsd</span><span class="o">.</span><span class="n">item</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">fsd</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="s2">&quot;noise_size&quot;</span><span class="p">]</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="s2">&quot;noise_size&quot;</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="s2">&quot;noise_size&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="s2">&quot;tol_fun&quot;</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fsd</span> <span class="o">=</span> <span class="mf">0.0</span>
            <span class="c1"># Since the function is fully-deterministic no need of stobads</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="s2">&quot;stobads&quot;</span><span class="p">]:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="s2">&quot;stobads&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">optim_state</span><span class="p">[</span><span class="s2">&quot;fsd&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fsd</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">u_best</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">u</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">optim_state</span><span class="p">[</span><span class="s2">&quot;usuccess&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">u_best</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">optim_state</span><span class="p">[</span><span class="s2">&quot;ysuccess&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">yval</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">optim_state</span><span class="p">[</span><span class="s2">&quot;fsuccess&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fval</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">optim_state</span><span class="p">[</span><span class="s2">&quot;u&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">u</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">optim_state</span><span class="p">[</span><span class="s2">&quot;u_success&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">optim_state</span><span class="p">[</span><span class="s2">&quot;y_success&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">optim_state</span><span class="p">[</span><span class="s2">&quot;f_success&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># Initialize Gaussian Process (GP) structure</span>
        <span class="n">gp</span><span class="p">,</span> <span class="n">Ns_gp</span><span class="p">,</span> <span class="n">sn2hpd</span><span class="p">,</span> <span class="n">hyp_dict</span> <span class="o">=</span> <span class="n">init_and_train_gp</span><span class="p">(</span>
            <span class="n">hyp_dict</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">optim_state</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">function_logger</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">iteration_history</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">plausible_lower_bounds</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">plausible_upper_bounds</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">gp_stats</span> <span class="o">=</span> <span class="n">IterationHistory</span><span class="p">(</span>
            <span class="p">[</span>
                <span class="s2">&quot;iter_gp&quot;</span><span class="p">,</span>
                <span class="s2">&quot;fval&quot;</span><span class="p">,</span>
                <span class="s2">&quot;ymu&quot;</span><span class="p">,</span>
                <span class="s2">&quot;ys&quot;</span><span class="p">,</span>
                <span class="s2">&quot;gp&quot;</span><span class="p">,</span>
            <span class="p">]</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">best_gp_hyp</span> <span class="o">=</span> <span class="n">gp</span><span class="o">.</span><span class="n">get_hyperparameters</span><span class="p">(</span><span class="n">as_array</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">return</span> <span class="p">(</span>
            <span class="n">gp</span><span class="p">,</span>
            <span class="n">Ns_gp</span><span class="p">,</span>
            <span class="n">sn2hpd</span><span class="p">,</span>
            <span class="n">hyp_dict</span><span class="p">,</span>
        <span class="p">)</span>

<div class="viewcode-block" id="BADS.optimize">
<a class="viewcode-back" href="../../../api/classes/bads.html#pybads.bads.BADS.optimize">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">optimize</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Run the optimization on an initialized ``PyBADS`` object.</span>
<span class="sd">        </span>
<span class="sd">        BADS starts at X0 and finds a local minimum X of the</span>
<span class="sd">        target function &#39;fun&#39;.</span>

<span class="sd">        A history of the optimization problem can be found at the ``self.iteration_history`` variable of the ``PyBADS`` object.</span>

<span class="sd">        Returns</span>
<span class="sd">        ----------</span>
<span class="sd">            optimize_result: OptimizeResult</span>
<span class="sd">                Dictionary containing the result of the optimization. See the documentation of the ``OptimizeResult`` class for more details.</span>
<span class="sd">                For example, retrieve the final solution with the following attributes:</span>
<span class="sd">                    -  ``optimize_result.x``</span>
<span class="sd">                    -  ``optimize_result.fval`` </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">is_finished</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">poll_iteration</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logging_action</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">timer</span> <span class="o">=</span> <span class="n">Timer</span><span class="p">()</span>
        <span class="n">timer</span><span class="o">.</span><span class="n">start_timer</span><span class="p">(</span><span class="s2">&quot;BADS&quot;</span><span class="p">)</span>
        <span class="n">hyp_dict</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">search_success</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">last_skipped</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="c1"># Last skipped iteration</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">search_spree</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">restarts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="s2">&quot;restarts&quot;</span><span class="p">]</span>

        <span class="c1"># Initialize gp</span>
        <span class="n">gp</span><span class="p">,</span> <span class="n">Ns_gp</span><span class="p">,</span> <span class="n">sn2hpd</span><span class="p">,</span> <span class="n">hyp_dict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_init_optimization_</span><span class="p">()</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">search_es_hedge</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># init search hedge to None</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="s2">&quot;output_fcn&quot;</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">output_fcn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="s2">&quot;output_fcn&quot;</span><span class="p">]</span>
            <span class="n">is_finished</span> <span class="o">=</span> <span class="n">output_fcn</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">var_transf</span><span class="o">.</span><span class="n">inverse_transf</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">u</span><span class="p">),</span> <span class="s2">&quot;init&quot;</span>
            <span class="p">)</span>

        <span class="n">poll_iteration</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">loop_iter</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="ow">not</span> <span class="n">is_finished</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">optim_state</span><span class="p">[</span><span class="s2">&quot;iter&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">poll_iteration</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">gp_refitted_flag</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">gp_exit_flag</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>
            <span class="n">action_txt</span> <span class="o">=</span> <span class="p">(</span>
                <span class="s2">&quot;&quot;</span>  <span class="c1"># Action performed this iteration (for printing purposes)</span>
            <span class="p">)</span>

            <span class="c1"># Compute mesh size and search mesh size</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mesh_size</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="s2">&quot;poll_mesh_multiplier&quot;</span><span class="p">]</span> <span class="o">**</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">mesh_size_integer</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">optim_state</span><span class="p">[</span><span class="s2">&quot;mesh_size&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh_size</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="s2">&quot;search_size_locked&quot;</span><span class="p">]:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">optim_state</span><span class="p">[</span><span class="s2">&quot;search_size_integer&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span>
                    <span class="mi">0</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">mesh_size_integer</span>
                    <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="s2">&quot;search_grid_multiplier&quot;</span><span class="p">]</span>
                    <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="s2">&quot;search_grid_number&quot;</span><span class="p">],</span>
                <span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">optim_state</span><span class="p">[</span><span class="s2">&quot;search_mesh_size&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="s2">&quot;poll_mesh_multiplier&quot;</span><span class="p">]</span>
                <span class="o">**</span> <span class="bp">self</span><span class="o">.</span><span class="n">optim_state</span><span class="p">[</span><span class="s2">&quot;search_size_integer&quot;</span><span class="p">]</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">search_mesh_size</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">optim_state</span><span class="p">[</span><span class="s2">&quot;search_mesh_size&quot;</span><span class="p">]</span>

            <span class="c1"># Update bounds to grid search mesh</span>
            <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">optim_state</span><span class="p">[</span><span class="s2">&quot;lb_search&quot;</span><span class="p">],</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">optim_state</span><span class="p">[</span><span class="s2">&quot;ub_search&quot;</span><span class="p">],</span>
            <span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_update_search_bounds_</span><span class="p">()</span>

            <span class="c1"># Minimum improvement for a poll/search to be considered successful</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sufficient_improvement</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="s2">&quot;tol_improvement&quot;</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">mesh_size</span> <span class="o">**</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="s2">&quot;forcing_exponent&quot;</span><span class="p">])</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="s2">&quot;sloppy_improvement&quot;</span><span class="p">]:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">sufficient_improvement</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">sufficient_improvement</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="s2">&quot;tol_fun&quot;</span><span class="p">]</span>
                <span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">optim_state</span><span class="p">[</span>
                <span class="s2">&quot;search_sufficient_improvement&quot;</span>
            <span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sufficient_improvement</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

            <span class="n">do_search_step_flag</span> <span class="o">=</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">optim_state</span><span class="p">[</span><span class="s2">&quot;search_count&quot;</span><span class="p">]</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="s2">&quot;search_n_try&quot;</span><span class="p">]</span>
                <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">function_logger</span><span class="o">.</span><span class="n">Y</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">function_logger</span><span class="o">.</span><span class="n">X_flag</span><span class="p">])</span>
                <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">D</span>
            <span class="p">)</span>

            <span class="k">if</span> <span class="n">do_search_step_flag</span><span class="p">:</span>
                <span class="c1"># Search stage</span>
                <span class="p">(</span>
                    <span class="n">u_search</span><span class="p">,</span>
                    <span class="n">search_dist</span><span class="p">,</span>
                    <span class="n">f_mu_search</span><span class="p">,</span>
                    <span class="n">f_sd_search</span><span class="p">,</span>
                    <span class="n">gp</span><span class="p">,</span>
                <span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_search_step_</span><span class="p">(</span><span class="n">gp</span><span class="p">)</span>
            <span class="c1"># End Search step</span>

            <span class="c1"># Check whether to perform the poll stage, it can be run consecutively after the search.</span>
            <span class="k">if</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">optim_state</span><span class="p">[</span><span class="s2">&quot;search_count&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span>
                <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">optim_state</span><span class="p">[</span><span class="s2">&quot;search_count&quot;</span><span class="p">]</span>
                <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="s2">&quot;search_n_try&quot;</span><span class="p">]</span>
            <span class="p">):</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">optim_state</span><span class="p">[</span><span class="s2">&quot;search_count&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">if</span> <span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">search_success</span> <span class="o">&gt;</span> <span class="mi">0</span>
                    <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="s2">&quot;skip_poll_after_search&quot;</span><span class="p">]</span>
                <span class="p">):</span>
                    <span class="n">do_poll_step</span> <span class="o">=</span> <span class="kc">False</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">search_spree</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="k">if</span> <span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="s2">&quot;search_mesh_expand&quot;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span>
                        <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">mod</span><span class="p">(</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">search_spree</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="s2">&quot;search_mesh_expand&quot;</span><span class="p">]</span>
                        <span class="p">)</span>
                        <span class="o">==</span> <span class="mi">0</span>
                        <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="s2">&quot;search_mesh_increment&quot;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span>
                    <span class="p">):</span>
                        <span class="c1"># Check if mesh size is already maximal</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_check_mesh_overflow_</span><span class="p">()</span>

                        <span class="bp">self</span><span class="o">.</span><span class="n">mesh_size_integer</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">mesh_size_integer</span>
                            <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="s2">&quot;search_mesh_increment&quot;</span><span class="p">],</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="s2">&quot;max_poll_grid_number&quot;</span><span class="p">],</span>
                        <span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">do_poll_step</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">search_spree</span> <span class="o">=</span> <span class="mi">0</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">search_success</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">else</span><span class="p">:</span>  <span class="c1"># In-between searches, no poll</span>
                <span class="n">do_poll_step</span> <span class="o">=</span> <span class="kc">False</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">u</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">u_best</span>

            <span class="c1"># check and do poll step</span>
            <span class="k">if</span> <span class="n">do_poll_step</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_poll_step_</span><span class="p">(</span><span class="n">gp</span><span class="p">)</span>

            <span class="c1"># Finalize the iteration</span>

            <span class="c1"># TODO: Iteration plot</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="s2">&quot;plot&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;scatter&quot;</span><span class="p">:</span>
                <span class="k">pass</span>

            <span class="c1"># GP hyperparameters at end of iteration</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">best_gp_hyp</span> <span class="o">=</span> <span class="n">gp</span><span class="o">.</span><span class="n">get_hyperparameters</span><span class="p">(</span><span class="n">as_array</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

            <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
            <span class="c1"># Check termination conditions</span>
            <span class="k">if</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">function_logger</span><span class="o">.</span><span class="n">func_count</span>
                <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="s2">&quot;max_fun_evals&quot;</span><span class="p">]</span>
            <span class="p">):</span>
                <span class="n">is_finished</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="c1"># exit_flag = 0</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Optimization terminated: reached maximum number of function evaluations options[&#39;max_fun_evals&#39;].&quot;</span>

            <span class="k">if</span> <span class="n">poll_iteration</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="s2">&quot;max_iter&quot;</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">is_finished</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="c1"># exit_flag = 0</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Optimization terminated: reached maximum number of iterations options[&#39;max_iter&#39;].&quot;</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">optim_state</span><span class="p">[</span><span class="s2">&quot;mesh_size&quot;</span><span class="p">]</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">optim_state</span><span class="p">[</span><span class="s2">&quot;tol_mesh&quot;</span><span class="p">]:</span>
                <span class="n">is_finished</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="c1"># exit_flag = 1</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Optimization terminated: change in the function value less than options[&#39;tol_mesh&#39;]&quot;</span>

            <span class="c1"># Historic improvement</span>
            <span class="k">if</span> <span class="n">poll_iteration</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="s2">&quot;tol_stall_iters&quot;</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">idx</span> <span class="o">=</span> <span class="n">poll_iteration</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="s2">&quot;tol_stall_iters&quot;</span><span class="p">]</span>
                <span class="n">f_base</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">iteration_history</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;fval&quot;</span><span class="p">)[</span><span class="n">idx</span><span class="p">]</span>
                <span class="n">f_sd_base</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">iteration_history</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;fsd&quot;</span><span class="p">)[</span><span class="n">idx</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">f_q_historic_improvement</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_eval_improvement_</span><span class="p">(</span>
                    <span class="n">f_base</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">fval</span><span class="p">,</span>
                    <span class="n">f_sd_base</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">fsd</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="s2">&quot;improvement_quantile&quot;</span><span class="p">],</span>
                <span class="p">)</span>

                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">f_q_historic_improvement</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="s2">&quot;tol_fun&quot;</span><span class="p">]:</span>
                    <span class="n">is_finished</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="n">exit_flag</span> <span class="o">=</span> <span class="mi">2</span>
                    <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Optimization terminated: change in the function value less than options[&#39;tol_fun&#39;].&quot;</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">optim_state</span><span class="p">[</span><span class="s2">&quot;termination_msg&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">msg</span>

            <span class="c1"># Store best points at the end of each iteration, or upon termination</span>
            <span class="k">if</span> <span class="n">do_poll_step</span> <span class="ow">or</span> <span class="n">is_finished</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">iteration_history</span><span class="o">.</span><span class="n">record</span><span class="p">(</span>
                    <span class="s2">&quot;u&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">u</span><span class="o">.</span><span class="n">flatten</span><span class="p">(),</span> <span class="n">poll_iteration</span>
                <span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">iteration_history</span><span class="o">.</span><span class="n">record</span><span class="p">(</span>
                    <span class="s2">&quot;x&quot;</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">var_transf</span><span class="o">.</span><span class="n">inverse_transf</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">u</span><span class="o">.</span><span class="n">flatten</span><span class="p">()),</span>
                    <span class="n">poll_iteration</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">iteration_history</span><span class="o">.</span><span class="n">record</span><span class="p">(</span>
                    <span class="s2">&quot;yval&quot;</span><span class="p">,</span> <span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">yval</span><span class="p">),</span> <span class="n">poll_iteration</span>
                <span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">iteration_history</span><span class="o">.</span><span class="n">record</span><span class="p">(</span>
                    <span class="s2">&quot;fval&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">fval</span><span class="p">,</span> <span class="n">poll_iteration</span>
                <span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">iteration_history</span><span class="o">.</span><span class="n">record</span><span class="p">(</span><span class="s2">&quot;fsd&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">fsd</span><span class="p">,</span> <span class="n">poll_iteration</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">iteration_history</span><span class="o">.</span><span class="n">record</span><span class="p">(</span>
                    <span class="s2">&quot;mesh_size&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh_size</span><span class="p">,</span> <span class="n">poll_iteration</span>
                <span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">iteration_history</span><span class="o">.</span><span class="n">record</span><span class="p">(</span>
                    <span class="s2">&quot;search_mesh_size&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">search_mesh_size</span><span class="p">,</span> <span class="n">poll_iteration</span>
                <span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">iteration_history</span><span class="o">.</span><span class="n">record</span><span class="p">(</span>
                    <span class="s2">&quot;gp_hyp_full&quot;</span><span class="p">,</span> <span class="n">gp</span><span class="o">.</span><span class="n">get_hyperparameters</span><span class="p">(</span><span class="kc">True</span><span class="p">),</span> <span class="n">poll_iteration</span>
                <span class="p">)</span>  <span class="c1"># corresponds to self.best_gp_hyp</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">iteration_history</span><span class="o">.</span><span class="n">record</span><span class="p">(</span><span class="s2">&quot;gp&quot;</span><span class="p">,</span> <span class="n">gp</span><span class="p">,</span> <span class="n">poll_iteration</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">iteration_history</span><span class="o">.</span><span class="n">record</span><span class="p">(</span>
                    <span class="s2">&quot;func_count&quot;</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">function_logger</span><span class="o">.</span><span class="n">func_count</span><span class="p">,</span>
                    <span class="n">poll_iteration</span><span class="p">,</span>
                <span class="p">)</span>

            <span class="c1"># Re-evaluate all noisy estimates at the end of the iteration</span>
            <span class="k">if</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">optim_state</span><span class="p">[</span><span class="s2">&quot;uncertainty_handling_level&quot;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span>
                <span class="ow">and</span> <span class="n">do_poll_step</span>
                <span class="ow">and</span> <span class="n">poll_iteration</span> <span class="o">&gt;</span> <span class="mi">0</span>
            <span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_re_evaluate_history_</span><span class="p">(</span><span class="n">gp</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">yval</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">iteration_history</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;yval&quot;</span><span class="p">)[</span><span class="n">poll_iteration</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">fval</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">iteration_history</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;fval&quot;</span><span class="p">)[</span><span class="n">poll_iteration</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">fsd</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">iteration_history</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;fsd&quot;</span><span class="p">)[</span><span class="n">poll_iteration</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">best_gp_hyp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">iteration_history</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;gp_hyp_full&quot;</span><span class="p">)[</span>
                    <span class="n">poll_iteration</span>
                <span class="p">]</span>
                <span class="n">gp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">iteration_history</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;gp&quot;</span><span class="p">)[</span><span class="n">poll_iteration</span><span class="p">]</span>

                <span class="n">f_q_re_impr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_eval_improvement_</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">fval</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">iteration_history</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;fval&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;float&quot;</span><span class="p">),</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">fsd</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">iteration_history</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;fsd&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;float&quot;</span><span class="p">),</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="s2">&quot;improvement_quantile&quot;</span><span class="p">],</span>
                <span class="p">)</span>
                <span class="n">f_q_re_impr</span> <span class="o">=</span> <span class="n">f_q_re_impr</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>  <span class="c1"># Skip the first iteration</span>
                <span class="n">idx_impr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">f_q_re_impr</span><span class="p">)</span>
                <span class="n">improvement</span> <span class="o">=</span> <span class="n">f_q_re_impr</span><span class="p">[</span><span class="n">idx_impr</span><span class="p">]</span>
                <span class="n">idx_impr</span> <span class="o">=</span> <span class="n">idx_impr</span> <span class="o">+</span> <span class="mi">1</span>  <span class="c1"># offset original index without skip</span>

                <span class="c1"># Check if any point got better</span>
                <span class="k">if</span> <span class="n">improvement</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="s2">&quot;tol_fun&quot;</span><span class="p">]:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">yval</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">iteration_history</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;yval&quot;</span><span class="p">)[</span><span class="n">idx_impr</span><span class="p">]</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">fval</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">iteration_history</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;fval&quot;</span><span class="p">)[</span><span class="n">idx_impr</span><span class="p">]</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">fsd</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">iteration_history</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;fsd&quot;</span><span class="p">)[</span><span class="n">idx_impr</span><span class="p">]</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">u</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">iteration_history</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;u&quot;</span><span class="p">)[</span><span class="n">idx_impr</span><span class="p">]</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">best_u</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">u</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">best_gp_hyp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">iteration_history</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
                        <span class="s2">&quot;gp_hyp_full&quot;</span>
                    <span class="p">)[</span><span class="n">idx_impr</span><span class="p">]</span>
                    <span class="n">gp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">iteration_history</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;gp&quot;</span><span class="p">)[</span>
                        <span class="n">idx_impr</span>
                    <span class="p">]</span>  <span class="c1"># overwrite best gp</span>

            <span class="c1"># if isFinished_flag</span>
            <span class="k">if</span> <span class="n">is_finished</span><span class="p">:</span>
                <span class="c1"># Multiple starts (deprecated)</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">restarts</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">pass</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">do_poll_step</span><span class="p">:</span>
                    <span class="c1"># Iteration corresponds to the number of polling iterations</span>
                    <span class="n">poll_iteration</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">optim_state</span><span class="p">[</span><span class="s2">&quot;iter&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">poll_iteration</span>

            <span class="n">loop_iter</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="c1"># End while</span>

        <span class="c1"># Re-evaluate all best points for noisy evaluations</span>
        <span class="n">yval_vec</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">yval</span> <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">yval</span><span class="p">)</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">yval</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">optim_state</span><span class="p">[</span><span class="s2">&quot;uncertainty_handling_level&quot;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span>
            <span class="ow">and</span> <span class="n">poll_iteration</span> <span class="o">&gt;</span> <span class="mi">0</span>
        <span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_re_evaluate_history_</span><span class="p">(</span><span class="n">gp</span><span class="p">)</span>

            <span class="c1"># Order by lowest probabilistic upper bound and choose</span>
            <span class="c1"># the point with the lowest quantile values of the history of the optimization run: inf{x: F(x)&gt;p}.</span>
            <span class="n">sigma_multiplier</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">erfcinv</span><span class="p">(</span>
                <span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="s2">&quot;final_quantile&quot;</span><span class="p">]</span>
            <span class="p">)</span>  <span class="c1"># Using inverted convention</span>
            <span class="n">q_beta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">iteration_history</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
                <span class="s2">&quot;fval&quot;</span>
            <span class="p">)</span> <span class="o">+</span> <span class="n">sigma_multiplier</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">iteration_history</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;fsd&quot;</span><span class="p">)</span>
            <span class="n">min_q_beta_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">q_beta</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>  <span class="c1"># Skip first iteration</span>
            <span class="n">min_q_beta_idx</span> <span class="o">+=</span> <span class="mi">1</span>  <span class="c1"># offset original index with no skip</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">yval</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">iteration_history</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;yval&quot;</span><span class="p">)[</span><span class="n">min_q_beta_idx</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fval</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">iteration_history</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;fval&quot;</span><span class="p">)[</span><span class="n">min_q_beta_idx</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fsd</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">iteration_history</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;fsd&quot;</span><span class="p">)[</span><span class="n">min_q_beta_idx</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">u</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">iteration_history</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;u&quot;</span><span class="p">)[</span><span class="n">min_q_beta_idx</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">u_best</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">u</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">best_gp_hyp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">iteration_history</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;gp_hyp_full&quot;</span><span class="p">)[</span>
                <span class="n">min_q_beta_idx</span>
            <span class="p">]</span>
            <span class="n">gp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">iteration_history</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;gp&quot;</span><span class="p">)[</span><span class="n">min_q_beta_idx</span><span class="p">]</span>

            <span class="c1"># Re-evalate estimated function value and SD at final point</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="s2">&quot;noise_final_samples&quot;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># Estimate function value and standard deviation at final point.</span>
                <span class="c1"># Note that by default we do *not* use YVAL because it is biased</span>
                <span class="c1"># (since it was an incumbent at some iteration, it is more likely to be a</span>
                <span class="c1"># random fluctuation lower than the mean)</span>
                <span class="n">yval_vec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="s2">&quot;noise_final_samples&quot;</span><span class="p">])</span>
                <span class="n">ysd_vec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="s2">&quot;noise_final_samples&quot;</span><span class="p">])</span>
                <span class="k">for</span> <span class="n">i_sample</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="s2">&quot;noise_final_samples&quot;</span><span class="p">]):</span>
                    <span class="n">y</span><span class="p">,</span> <span class="n">y_sd</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">function_logger</span><span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">u</span><span class="p">,</span> <span class="n">record_duplicate_data</span><span class="o">=</span><span class="kc">False</span>
                    <span class="p">)</span>
                    <span class="n">yval_vec</span><span class="p">[</span><span class="n">i_sample</span><span class="p">]</span> <span class="o">=</span> <span class="n">y</span>
                    <span class="n">ysd_vec</span><span class="p">[</span><span class="n">i_sample</span><span class="p">]</span> <span class="o">=</span> <span class="n">y_sd</span>

                <span class="k">if</span> <span class="n">yval_vec</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">yval_vec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">yval_vec</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">yval</span><span class="p">))</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="s2">&quot;specify_target_noise&quot;</span><span class="p">]:</span>
                        <span class="n">ysd_vec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span>
                            <span class="p">(</span>
                                <span class="n">ysd_vec</span><span class="p">,</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">function_logger</span><span class="o">.</span><span class="n">S</span><span class="p">[</span>
                                    <span class="bp">self</span><span class="o">.</span><span class="n">function_logger</span><span class="o">.</span><span class="n">Xn</span>
                                <span class="p">],</span>
                            <span class="p">)</span>
                        <span class="p">)</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">optim_state</span><span class="p">[</span><span class="s2">&quot;yval_vec&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">yval_vec</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">optim_state</span><span class="p">[</span><span class="s2">&quot;ysd_vec&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">ysd_vec</span><span class="p">)</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">fval</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">yval_vec</span><span class="p">)</span><span class="o">.</span><span class="n">item</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">fsd</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">yval_vec</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">yval_vec</span><span class="o">.</span><span class="n">size</span><span class="p">))</span><span class="o">.</span><span class="n">item</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">iteration_history</span><span class="o">.</span><span class="n">record</span><span class="p">(</span>
                    <span class="s2">&quot;fval&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">fval</span><span class="p">,</span> <span class="n">poll_iteration</span>
                <span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">iteration_history</span><span class="o">.</span><span class="n">record</span><span class="p">(</span><span class="s2">&quot;fsd&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">fsd</span><span class="p">,</span> <span class="n">poll_iteration</span><span class="p">)</span>

        <span class="c1"># Convert back to original space</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">var_transf</span><span class="o">.</span><span class="n">inverse_transf</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">u</span><span class="p">)</span>

        <span class="c1"># Compute total running time and fractional overhead</span>
        <span class="n">timer</span><span class="o">.</span><span class="n">stop_timer</span><span class="p">(</span><span class="s2">&quot;BADS&quot;</span><span class="p">)</span>
        <span class="n">total_time</span> <span class="o">=</span> <span class="n">timer</span><span class="o">.</span><span class="n">get_duration</span><span class="p">(</span><span class="s2">&quot;BADS&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">function_logger</span><span class="o">.</span><span class="n">total_fun_eval_time</span> <span class="o">&gt;</span> <span class="mf">0.0</span><span class="p">:</span>
            <span class="n">overhead</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">total_time</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">function_logger</span><span class="o">.</span><span class="n">total_fun_eval_time</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">overhead</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">optim_state</span><span class="p">[</span><span class="s2">&quot;total_time&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">total_time</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">optim_state</span><span class="p">[</span><span class="s2">&quot;overhead&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">overhead</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">optim_state</span><span class="p">[</span><span class="s2">&quot;uncertainty_handling_level&quot;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">yval_vec</span><span class="p">)</span> <span class="ow">or</span> <span class="n">yval_vec</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Observed function value at minimum: </span><span class="si">{</span><span class="n">yval_vec</span><span class="si">}</span><span class="s2"> (1 sample). Estimated: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">fval</span><span class="si">}</span><span class="s2">  </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">fsd</span><span class="si">}</span><span class="s2"> (GP mean  SEM).&quot;</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Estimated function value at minimum: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">fval</span><span class="si">}</span><span class="s2">  </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">fsd</span><span class="si">}</span><span class="s2"> (mean  SEM from </span><span class="si">{</span><span class="n">yval_vec</span><span class="o">.</span><span class="n">size</span><span class="si">}</span><span class="s2"> samples)&quot;</span>
                <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Function value at minimum: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">fval</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># BADS&#39;s output</span>
        <span class="n">optimize_result</span> <span class="o">=</span> <span class="n">OptimizeResult</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">optimize_result</span></div>

    
    <span class="k">def</span><span class="w"> </span><span class="nf">_search_step_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">gp</span><span class="p">:</span> <span class="n">GP</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A private method that performs the search method using hedging search of Evolution Strategy (ES) searches.</span>
<span class="sd">        It also evaluates the performance of the search (success, unsuccess)</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        gp : gpyreg.gaussian_process.GP</span>

<span class="sd">        Returns</span>
<span class="sd">        ----------</span>
<span class="sd">        u_search : np.ndarray</span>
<span class="sd">            Candidate search point.</span>
<span class="sd">        search_dist : np.ndarray</span>
<span class="sd">            Distance of the search point from thecurrent point.</span>
<span class="sd">        f_mu_search : float</span>
<span class="sd">            Estimated mean function at the candidate search point.</span>
<span class="sd">        f_sd_search : float</span>
<span class="sd">            Estimated noise at the candidate search point.</span>
<span class="sd">        gp : gpyreg.gaussian_process.GP</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Check whether it is time to refit the GP</span>
        <span class="n">refit_flag</span><span class="p">,</span> <span class="n">do_gp_calibration</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_gp_refit_time_</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="s2">&quot;normalpha_level&quot;</span><span class="p">]</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="p">(</span>
            <span class="n">refit_flag</span>
            <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">optim_state</span><span class="p">[</span><span class="s2">&quot;search_count&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span>
            <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">reset_gp</span>
        <span class="p">):</span>
            <span class="c1"># Local GP approximation on current incumbent</span>
            <span class="n">gp</span><span class="p">,</span> <span class="n">gp_exit_flag</span> <span class="o">=</span> <span class="n">local_gp_fitting</span><span class="p">(</span>
                <span class="n">gp</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">u</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">function_logger</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">optim_state</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">iteration_history</span><span class="p">,</span>
                <span class="n">refit_flag</span><span class="p">,</span>
            <span class="p">)</span>

            <span class="k">if</span> <span class="n">refit_flag</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">gp_refitted_flag</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">gp_exit_flag</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">gp_exit_flag</span><span class="p">,</span> <span class="n">gp_exit_flag</span><span class="p">)</span>
        <span class="c1"># End fitting</span>

        <span class="c1"># Update Target from GP prediction</span>
        <span class="n">f_target_mu</span><span class="p">,</span> <span class="n">f_target_s</span><span class="p">,</span> <span class="n">f_target</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_target_from_gp_</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">u_best</span><span class="p">,</span> <span class="n">gp</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">best_gp_hyp</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">optim_state</span><span class="p">[</span><span class="s2">&quot;f_target_mu&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">f_target_mu</span><span class="o">.</span><span class="n">item</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">optim_state</span><span class="p">[</span><span class="s2">&quot;f_target_s&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">f_target_s</span> <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">f_target_s</span><span class="p">)</span> <span class="k">else</span> <span class="n">f_target_s</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">optim_state</span><span class="p">[</span><span class="s2">&quot;f_target&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">f_target</span><span class="o">.</span><span class="n">item</span><span class="p">()</span>

        <span class="c1"># Generate search set (normalized coordinate)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">optim_state</span><span class="p">[</span><span class="s2">&quot;search_count&quot;</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">search_es_hedge</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">search_es_hedge</span> <span class="o">=</span> <span class="n">ESSearchHedge</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="s2">&quot;search_method&quot;</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">non_box_cons</span>
            <span class="p">)</span>
        <span class="n">u_search_set</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">search_es_hedge</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">u</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">lower_bounds</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">upper_bounds</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">function_logger</span><span class="p">,</span>
            <span class="n">gp</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">optim_state</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># Enforce periodicity</span>
        <span class="n">u_search_set</span> <span class="o">=</span> <span class="n">period_check</span><span class="p">(</span>
            <span class="n">u_search_set</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">lower_bounds</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">upper_bounds</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">optim_state</span><span class="p">[</span><span class="s2">&quot;periodic_vars&quot;</span><span class="p">],</span>
        <span class="p">)</span>

        <span class="c1"># Force candidate points on search grid</span>
        <span class="n">u_search_set</span> <span class="o">=</span> <span class="n">force_to_grid</span><span class="p">(</span>
            <span class="n">u_search_set</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">optim_state</span><span class="p">[</span><span class="s2">&quot;search_mesh_size&quot;</span><span class="p">]</span>
        <span class="p">)</span>

        <span class="c1"># Remove already evaluated or unfeasible points from search set</span>
        <span class="n">u_search_set</span> <span class="o">=</span> <span class="n">contraints_check</span><span class="p">(</span>
            <span class="n">u_search_set</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">optim_state</span><span class="p">[</span><span class="s2">&quot;lb_search&quot;</span><span class="p">],</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">optim_state</span><span class="p">[</span><span class="s2">&quot;ub_search&quot;</span><span class="p">],</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">optim_state</span><span class="p">[</span><span class="s2">&quot;tol_mesh&quot;</span><span class="p">],</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">function_logger</span><span class="p">,</span>
            <span class="kc">True</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">non_box_cons</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># The Acquisition Hedge policy is not yet supported (even in Matlab)</span>
        <span class="n">index_acq</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">u_search_set</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># Batch evaluation of acquisition function on search set</span>
            <span class="n">z</span><span class="p">,</span> <span class="n">f_mu</span><span class="p">,</span> <span class="n">fs</span> <span class="o">=</span> <span class="n">acq_fcn_lcb</span><span class="p">(</span><span class="n">u_search_set</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">function_logger</span><span class="o">.</span><span class="n">func_count</span><span class="p">,</span> <span class="n">gp</span><span class="p">)</span>
            <span class="c1"># Evaluate best candidate point in original coordinates</span>
            <span class="n">index_acq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>

            <span class="c1"># TODO: In future handle acquisition portfolio (Acquisition Hedge), it&#39;s not even unsupported in Matlab</span>

            <span class="c1"># Randomly choose index if something went wrong</span>
            <span class="k">if</span> <span class="p">(</span>
                <span class="n">index_acq</span> <span class="ow">is</span> <span class="kc">None</span>
                <span class="ow">or</span> <span class="n">index_acq</span><span class="o">.</span><span class="n">size</span> <span class="o">&lt;</span> <span class="mi">1</span>
                <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">index_acq</span><span class="p">))</span>
            <span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;bads:optimize: Acquisition function failed&quot;</span><span class="p">)</span>
                <span class="n">index_acq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">u_search_set</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

            <span class="c1"># u_search at the candidate acquisition point</span>
            <span class="n">u_search</span> <span class="o">=</span> <span class="n">u_search_set</span><span class="p">[</span><span class="n">index_acq</span><span class="p">]</span>

            <span class="c1"># TODO: Local optimization of the acquisition function (generally it does not improve results)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="s2">&quot;search_optimize&quot;</span><span class="p">]:</span>
                <span class="k">pass</span>

            <span class="n">y_search</span><span class="p">,</span> <span class="n">f_sd_search</span><span class="p">,</span> <span class="n">idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">function_logger</span><span class="p">(</span><span class="n">u_search</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">z</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># Save statistics of gp prediction,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_save_gp_stats_</span><span class="p">(</span><span class="n">y_search</span><span class="p">,</span> <span class="n">f_mu</span><span class="p">[</span><span class="n">index_acq</span><span class="p">]</span><span class="o">.</span><span class="n">item</span><span class="p">(),</span>
                                    <span class="n">fs</span><span class="p">[</span><span class="n">index_acq</span><span class="p">]</span><span class="o">.</span><span class="n">item</span><span class="p">())</span>

            <span class="c1"># Add search point to training setMeshSize</span>
            <span class="k">if</span> <span class="p">(</span>
                <span class="n">u_search</span><span class="o">.</span><span class="n">size</span>
                <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;</span> <span class="bp">self</span><span class="o">.</span><span class="n">search_es_hedge</span><span class="o">.</span><span class="n">count</span>
                <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="s2">&quot;search_n_try&quot;</span><span class="p">]</span>
            <span class="p">):</span>
                <span class="c1"># TODO: Handle fitness_shaping and rotate gp axes (latter one is unsupported)</span>
                <span class="n">gp</span> <span class="o">=</span> <span class="n">add_and_update_gp</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">function_logger</span><span class="p">,</span>
                    <span class="n">gp</span><span class="p">,</span>
                    <span class="n">u_search</span><span class="p">,</span>
                    <span class="n">y_search</span><span class="p">,</span>
                    <span class="n">f_sd_search</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">,</span>
                <span class="p">)</span>

                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">gp</span><span class="o">.</span><span class="n">y</span><span class="p">)):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;bads:opt: GP prediction is non-finite&quot;</span><span class="p">)</span>

            <span class="c1"># If the function is non-deterministic we update the posterior of the GP with the new point</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">optim_state</span><span class="p">[</span><span class="s2">&quot;uncertainty_handling_level&quot;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">new_gp</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">gp</span><span class="p">)</span>
                <span class="c1"># Update priors and posteriors</span>
                <span class="n">new_gp</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">local_gp_fitting</span><span class="p">(</span>
                    <span class="n">new_gp</span><span class="p">,</span>
                    <span class="n">u_search</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">function_logger</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">optim_state</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">iteration_history</span><span class="p">,</span>
                    <span class="kc">False</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="n">f_mu_search</span><span class="p">,</span> <span class="n">f_sd_search</span> <span class="o">=</span> <span class="n">new_gp</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">u_search</span><span class="p">)</span>
                <span class="p">)</span>
                <span class="n">f_mu_search</span> <span class="o">=</span> <span class="n">f_mu_search</span><span class="o">.</span><span class="n">item</span><span class="p">()</span>
                <span class="n">f_sd_search</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">f_sd_search</span><span class="p">)</span><span class="o">.</span><span class="n">item</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">f_mu_search</span> <span class="o">=</span> <span class="n">y_search</span>
                <span class="n">f_sd_search</span> <span class="o">=</span> <span class="mi">0</span>

            <span class="c1"># Compute distance of search point from current point</span>
            <span class="n">search_dist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span>
                <span class="n">udist</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">u_best</span><span class="p">,</span>
                    <span class="n">u_search</span><span class="p">,</span>
                    <span class="n">gp</span><span class="o">.</span><span class="n">temporary_data</span><span class="p">[</span><span class="s2">&quot;len_scale&quot;</span><span class="p">],</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">optim_state</span><span class="p">[</span><span class="s2">&quot;lb&quot;</span><span class="p">],</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">optim_state</span><span class="p">[</span><span class="s2">&quot;ub&quot;</span><span class="p">],</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">optim_state</span><span class="p">[</span><span class="s2">&quot;scale&quot;</span><span class="p">],</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">optim_state</span><span class="p">[</span><span class="s2">&quot;periodic_vars&quot;</span><span class="p">],</span>
                <span class="p">)</span>
            <span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Search set is empty</span>
            <span class="n">y_search</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">yval</span>
            <span class="n">f_mu_search</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fval</span>
            <span class="n">f_sd_search</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">search_dist</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># TODO: CMA-ES like estimation of local covariance structure (unused)</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="s2">&quot;hessian_update&quot;</span><span class="p">]</span>
            <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="s2">&quot;hessian_method&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;cmaes&quot;</span>
        <span class="p">):</span>
            <span class="k">pass</span>

        <span class="n">fval_old</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fval</span>

        <span class="c1"># Evaluate search</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="s2">&quot;stobads&quot;</span><span class="p">]:</span>
            <span class="n">search_improvement</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_eval_improvement_</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">fval</span><span class="p">,</span>
                <span class="n">f_mu_search</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">fsd</span><span class="p">,</span>
                <span class="n">f_sd_search</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="s2">&quot;improvement_quantile&quot;</span><span class="p">],</span>
            <span class="p">)</span>

            <span class="c1"># Declare if search was success or not</span>
            <span class="n">is_search_success</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">search_improvement</span>
                <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">optim_state</span><span class="p">[</span><span class="s2">&quot;search_sufficient_improvement&quot;</span><span class="p">]</span>
            <span class="p">)</span>
            <span class="n">is_search_improved</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">search_improvement</span> <span class="o">&gt;</span> <span class="mi">0</span>
                <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="s2">&quot;sloppy_improvement&quot;</span><span class="p">]</span>
                <span class="ow">or</span> <span class="n">is_search_success</span>
            <span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># For StoBads an improvement corresponds to a success</span>
            <span class="n">sto_success</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sto_success_improvement_</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">fval</span><span class="p">,</span>
                <span class="n">f_mu_search</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">fsd</span><span class="p">,</span>
                <span class="n">f_sd_search</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">mesh_size</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">gamma_uncertain_interval</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="s2">&quot;opp_stobads&quot;</span><span class="p">]:</span>
                <span class="n">is_search_improved</span> <span class="o">=</span> <span class="n">sto_success</span> <span class="o">&gt;</span> <span class="o">-</span><span class="mi">1</span>
                <span class="n">is_search_success</span> <span class="o">=</span> <span class="n">sto_success</span> <span class="o">==</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">is_search_improved</span> <span class="o">=</span> <span class="n">sto_success</span> <span class="o">==</span> <span class="mi">1</span>
                <span class="n">is_search_success</span> <span class="o">=</span> <span class="n">is_search_improved</span>

        <span class="c1"># A search improvement implies an update of the incumbent</span>
        <span class="k">if</span> <span class="n">is_search_improved</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="s2">&quot;acq_hedge&quot;</span><span class="p">]:</span>
                <span class="c1"># Acquisition hedge (acquisition portfolio) not supported yet</span>
                <span class="k">pass</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">method</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">search_es_hedge</span><span class="o">.</span><span class="n">chosen_search_fun</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

            <span class="c1"># StoBads or sufficient improvement</span>
            <span class="k">if</span> <span class="n">is_search_success</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">search_success</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">search_string</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;Successful search (</span><span class="si">{</span><span class="n">method</span><span class="si">}</span><span class="s2">)&quot;</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">optim_state</span><span class="p">[</span><span class="s2">&quot;u_success&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">u_search</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">optim_state</span><span class="p">[</span><span class="s2">&quot;y_success&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">y_search</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">optim_state</span><span class="p">[</span><span class="s2">&quot;f_success&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">f_mu_search</span><span class="p">)</span>
                <span class="n">search_status</span> <span class="o">=</span> <span class="s2">&quot;success&quot;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">search_string</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;Incremental search (</span><span class="si">{</span><span class="n">method</span><span class="si">}</span><span class="s2">)&quot;</span>
                <span class="n">search_status</span> <span class="o">=</span> <span class="s2">&quot;incremental&quot;</span>

            <span class="c1"># Update incumbent point (self.yval, self.fval, self.fsd) and optim_state</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_update_incumbent_</span><span class="p">(</span>
                <span class="n">u_search</span><span class="p">,</span> <span class="n">y_search</span><span class="p">,</span> <span class="n">f_mu_search</span><span class="p">,</span> <span class="n">f_sd_search</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">optim_state</span><span class="p">[</span><span class="s2">&quot;uncertainty_handling_level&quot;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">gp</span> <span class="o">=</span> <span class="n">new_gp</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">reset_gp</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">search_status</span> <span class="o">=</span> <span class="s2">&quot;failure&quot;</span>
            <span class="n">search_string</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>

        <span class="c1"># Update portfolio acquisition function (not supported)</span>

        <span class="c1"># Update search portfolio (needs improvement)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">search_es_hedge</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">u_search_set</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">search_es_hedge</span><span class="o">.</span><span class="n">update_hedge</span><span class="p">(</span>
                <span class="n">u_search</span><span class="p">,</span>
                <span class="n">fval_old</span><span class="p">,</span>
                <span class="n">f_mu_search</span><span class="p">,</span>
                <span class="n">f_sd_search</span><span class="p">,</span>
                <span class="n">gp</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">optim_state</span><span class="p">[</span><span class="s2">&quot;mesh_size&quot;</span><span class="p">],</span>
            <span class="p">)</span>

        <span class="c1"># Update search statistics and search scale factor</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_update_search_stats_</span><span class="p">(</span><span class="n">search_status</span><span class="p">,</span> <span class="n">search_dist</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">search_string</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logging_action</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_display_function_log_</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">optim_state</span><span class="p">[</span><span class="s2">&quot;iter&quot;</span><span class="p">],</span> <span class="n">search_string</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="n">u_search</span><span class="p">,</span> <span class="n">search_dist</span><span class="p">,</span> <span class="n">f_mu_search</span><span class="p">,</span> <span class="n">f_sd_search</span><span class="p">,</span> <span class="n">gp</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_eval_improvement_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">f_base</span><span class="p">,</span> <span class="n">f_new</span><span class="p">,</span> <span class="n">s_base</span><span class="p">,</span> <span class="n">s_new</span><span class="p">,</span> <span class="n">q</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A private method that compute the optimization improvement.</span>

<span class="sd">        Returns</span>
<span class="sd">        ----------</span>
<span class="sd">        z : np.array</span>
<span class="sd">            It is the improvement of f_new over f_base for a minimization problem (larger improvements are better).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">s_base</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">s_new</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">z</span> <span class="o">=</span> <span class="n">f_base</span> <span class="o">-</span> <span class="n">f_new</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># This needs to be corrected -- but for q=0.5 it does not matter</span>
            <span class="n">mu</span> <span class="o">=</span> <span class="n">f_base</span> <span class="o">-</span> <span class="n">f_new</span>
            <span class="n">sigma</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">s_base</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">s_new</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
            <span class="n">x0</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">erfcinv</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">q</span><span class="p">)</span>
            <span class="n">z</span> <span class="o">=</span> <span class="n">sigma</span> <span class="o">*</span> <span class="n">x0</span> <span class="o">+</span> <span class="n">mu</span>
            <span class="n">z</span> <span class="o">=</span> <span class="n">z</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">z</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_sto_success_improvement_</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">f_base</span><span class="p">,</span>
        <span class="n">f_new</span><span class="p">,</span>
        <span class="n">s_base</span><span class="p">,</span>
        <span class="n">s_new</span><span class="p">,</span>
        <span class="n">frame_size</span><span class="p">,</span>
        <span class="n">gamma_uncertain_interval</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            A private method that evaluates if the improvement in the candidate incumbent using the uncertain interval method proposed in Sto-MADS [1].</span>
<span class="sd">        Returns</span>
<span class="sd">        ----------</span>
<span class="sd">            int : Return a flag integer value</span>
<span class="sd">                1   : sucessuful improvement</span>
<span class="sd">                0   : uncertain unsuccessful incumbent</span>
<span class="sd">                -1  : certain unsuccessful incumbent</span>

<span class="sd">        References</span>
<span class="sd">        ----------</span>
<span class="sd">        [1] Audet, Charles, Kwassi Joseph Dzahini, Michael Kokkolaras, and Sbastien Le Digabel. Stochastic Mesh Adaptive Direct Search for Blackbox Optimization Using Probabilistic Estimates. Computational Optimization and Applications 79, no. 1 (May 2021): 134. https://doi.org/10.1007/s10589-020-00249-0.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">epsilon</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">s_base</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">s_new</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">mu</span> <span class="o">=</span> <span class="n">f_base</span> <span class="o">-</span> <span class="n">f_new</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">gamma_uncertain_interval</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">gamma</span> <span class="o">=</span> <span class="mf">1.96</span>  <span class="c1"># gamma = norminv(0.975)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">gamma</span> <span class="o">=</span> <span class="n">gamma_uncertain_interval</span>  <span class="c1"># gamma = norminv(0.975)</span>

        <span class="n">ub_uncertain_interval</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">gamma</span>
            <span class="o">*</span> <span class="n">epsilon</span>
            <span class="o">*</span> <span class="n">frame_size</span> <span class="o">**</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="s2">&quot;stobads_frame_size_scaling_power&quot;</span><span class="p">])</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="n">mu</span> <span class="o">&gt;=</span> <span class="n">ub_uncertain_interval</span><span class="p">:</span>
            <span class="c1"># Successful</span>
            <span class="k">return</span> <span class="mi">1</span>
        <span class="k">elif</span> <span class="n">mu</span> <span class="o">&lt;=</span> <span class="o">-</span><span class="n">ub_uncertain_interval</span><span class="p">:</span>
            <span class="c1"># Certain unsuccessful</span>
            <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>

        <span class="c1"># Uncertain unsuccessful</span>
        <span class="k">return</span> <span class="mi">0</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_poll_step_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">gp</span><span class="p">:</span> <span class="n">GP</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A private method that performs poll step using the LTMADS poll direction method.</span>
<span class="sd">        It also evaluates and update the incumbent and the poll parameters (like the ``mesh_size_integer``) according to the found improvement.</span>

<span class="sd">        Returns</span>
<span class="sd">        ---------</span>
<span class="sd">        u_poll_best : np.array</span>
<span class="sd">            Best poll point.</span>
<span class="sd">        f_poll_best : float</span>
<span class="sd">            GP prediction of the best poll point.</span>
<span class="sd">        y_poll_best : float</span>
<span class="sd">            Function value at the best poll point.</span>
<span class="sd">        f_sd_poll_best : float</span>
<span class="sd">            Estimated GP variance at the best poll point.</span>
<span class="sd">        gp : gpyreg.gaussian_process.GP</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">poll_best_improvement</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">u_poll_best</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">u</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">y_poll_best</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">yval</span>
        <span class="n">f_poll_best</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fval</span>
        <span class="n">f_sd_poll_best</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fsd</span>
        <span class="n">gp_poll_hyp_best</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">best_gp_hyp</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">poll_count</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">certain_good_poll</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">sto_success</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">B</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">u_poll</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">u_new</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># Poll loop</span>
        <span class="k">while</span> <span class="p">(</span>
            <span class="p">(</span>
                <span class="p">(</span><span class="n">u_poll</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">u_poll</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
                <span class="ow">or</span> <span class="p">(</span><span class="n">B</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">B</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">function_logger</span><span class="o">.</span><span class="n">func_count</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="s2">&quot;max_fun_evals&quot;</span><span class="p">]</span>
            <span class="ow">and</span> <span class="n">poll_count</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">D</span> <span class="o">*</span> <span class="mi">2</span>
        <span class="p">):</span>

            <span class="c1"># Fill in basis vectors (when poll_count == 0)</span>
            <span class="k">if</span> <span class="n">B</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">B</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># Create new poll vectors</span>
                <span class="n">B_new</span> <span class="o">=</span> <span class="n">poll_mads_2n</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">D</span><span class="p">,</span>
                    <span class="n">gp</span><span class="o">.</span><span class="n">temporary_data</span><span class="p">[</span><span class="s2">&quot;poll_scale&quot;</span><span class="p">],</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">optim_state</span><span class="p">[</span><span class="s2">&quot;search_mesh_size&quot;</span><span class="p">],</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">optim_state</span><span class="p">[</span><span class="s2">&quot;mesh_size&quot;</span><span class="p">],</span>
                <span class="p">)</span>

                <span class="c1"># GP- based vector scaling (poll_scale broadcast)</span>
                <span class="n">vv</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">B_new</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">optim_state</span><span class="p">[</span><span class="s2">&quot;mesh_size&quot;</span><span class="p">]</span>
                <span class="p">)</span> <span class="o">*</span> <span class="n">gp</span><span class="o">.</span><span class="n">temporary_data</span><span class="p">[</span>
                    <span class="s2">&quot;poll_scale&quot;</span>
                <span class="p">]</span>  <span class="c1"># scaling again using broadcast</span>

                <span class="c1"># Add vector to current point, fix to grid</span>
                <span class="n">u_poll_new</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">u</span> <span class="o">+</span> <span class="n">vv</span>
                <span class="n">period_check</span><span class="p">(</span>
                    <span class="n">u_poll_new</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">lower_bounds</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">upper_bounds</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">optim_state</span><span class="p">[</span><span class="s2">&quot;periodic_vars&quot;</span><span class="p">],</span>
                <span class="p">)</span>

                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="s2">&quot;force_poll_mesh&quot;</span><span class="p">]:</span>
                    <span class="n">u_poll_new</span> <span class="o">=</span> <span class="n">force_to_grid</span><span class="p">(</span>
                        <span class="n">u_poll_new</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">optim_state</span><span class="p">[</span><span class="s2">&quot;search_mesh_size&quot;</span><span class="p">]</span>
                    <span class="p">)</span>

                <span class="n">u_poll_new</span> <span class="o">=</span> <span class="n">contraints_check</span><span class="p">(</span>
                    <span class="n">u_poll_new</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">lower_bounds</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">upper_bounds</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">optim_state</span><span class="p">[</span><span class="s2">&quot;tol_mesh&quot;</span><span class="p">],</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">function_logger</span><span class="p">,</span>
                    <span class="kc">False</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">non_box_cons</span><span class="p">,</span>
                <span class="p">)</span>

                <span class="c1"># Add new poll points to polling set</span>
                <span class="k">if</span> <span class="n">u_poll</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">u_poll</span> <span class="o">=</span> <span class="n">u_poll_new</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">u_poll</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">u_poll</span><span class="p">,</span> <span class="n">u_poll_new</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">B</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">B</span> <span class="o">=</span> <span class="n">B_new</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">B</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">B</span><span class="p">,</span> <span class="n">B_new</span><span class="p">))</span>

            <span class="c1"># Cannot refill poll vector set, stop polling</span>
            <span class="k">if</span> <span class="n">u_poll</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">u_poll</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">break</span>

            <span class="c1"># Check whether it is time to refit the GP</span>
            <span class="n">refit_flag</span><span class="p">,</span> <span class="n">do_gp_calibration</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_gp_refit_time_</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="s2">&quot;normalpha_level&quot;</span><span class="p">]</span>
            <span class="p">)</span>

            <span class="k">if</span> <span class="p">(</span>
                <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="s2">&quot;poll_training&quot;</span><span class="p">]</span>
                <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">optim_state</span><span class="p">[</span><span class="s2">&quot;iter&quot;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span>
            <span class="p">):</span>
                <span class="n">refit_flag</span> <span class="o">=</span> <span class="kc">False</span>

            <span class="c1"># Local GP approximation around polled points</span>
            <span class="k">if</span> <span class="n">refit_flag</span> <span class="ow">or</span> <span class="n">poll_count</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">reset_gp</span><span class="p">:</span>
                <span class="n">gp</span><span class="p">,</span> <span class="n">gp_exit_flag</span> <span class="o">=</span> <span class="n">local_gp_fitting</span><span class="p">(</span>
                    <span class="n">gp</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">u</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">function_logger</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">optim_state</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">iteration_history</span><span class="p">,</span>
                    <span class="n">refit_flag</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="k">if</span> <span class="n">refit_flag</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">gp_refitted_flag</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">gp_exit_flag</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">gp_exit_flag</span><span class="p">,</span> <span class="n">gp_exit_flag</span><span class="p">)</span>

            <span class="c1"># Update Target from GP prediction</span>
            <span class="n">f_target_mu</span><span class="p">,</span> <span class="n">f_target_s</span><span class="p">,</span> <span class="n">f_target</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_target_from_gp_</span><span class="p">(</span>
                <span class="n">u_poll_best</span><span class="p">,</span> <span class="n">gp</span><span class="p">,</span> <span class="n">gp_poll_hyp_best</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">optim_state</span><span class="p">[</span><span class="s2">&quot;f_target_mu&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">f_target_mu</span><span class="o">.</span><span class="n">item</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">optim_state</span><span class="p">[</span><span class="s2">&quot;f_target_s&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">f_target_s</span> <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">f_target_s</span><span class="p">)</span> <span class="k">else</span> <span class="n">f_target_s</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">optim_state</span><span class="p">[</span><span class="s2">&quot;f_target&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">f_target</span><span class="o">.</span><span class="n">item</span><span class="p">()</span>

            <span class="c1"># Evaluate acquisition function on poll vectors</span>
            <span class="c1"># Batch evaluation of acquisition function on search set (The Acquisition Hedge policy is not yet supported (even in Matlab))</span>
            <span class="n">z</span><span class="p">,</span> <span class="n">f_mu</span><span class="p">,</span> <span class="n">fs</span> <span class="o">=</span> <span class="n">acq_fcn_lcb</span><span class="p">(</span><span class="n">u_poll</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">function_logger</span><span class="o">.</span><span class="n">func_count</span><span class="p">,</span> <span class="n">gp</span><span class="p">)</span>
            <span class="c1"># Evaluate best candidate point in original coordinates</span>
            <span class="n">index_acq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>

            <span class="c1"># In future handle acquisition portfolio (Acquisition Hedge), it&#39;s even unsupported in Matlab</span>

            <span class="c1"># Randomly choose index if something went wrong</span>
            <span class="k">if</span> <span class="p">(</span>
                <span class="n">index_acq</span> <span class="ow">is</span> <span class="kc">None</span>
                <span class="ow">or</span> <span class="n">index_acq</span><span class="o">.</span><span class="n">size</span> <span class="o">&lt;</span> <span class="mi">1</span>
                <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">index_acq</span><span class="p">))</span>
            <span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;bads:optimize: Acquisition function failed&quot;</span><span class="p">)</span>
                <span class="n">index_acq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">u_poll</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">()</span><span class="o">.</span><span class="n">level</span> <span class="o">&gt;</span> <span class="n">logging</span><span class="o">.</span><span class="n">DEBUG</span><span class="p">:</span>
                <span class="n">np</span><span class="o">.</span><span class="n">seterr</span><span class="p">(</span><span class="n">divide</span><span class="o">=</span><span class="s2">&quot;ignore&quot;</span><span class="p">)</span>
            <span class="n">gamma_z</span> <span class="o">=</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">optim_state</span><span class="p">[</span><span class="s2">&quot;f_target&quot;</span><span class="p">]</span>
                <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">sufficient_improvement</span>
                <span class="o">-</span> <span class="n">f_mu</span>
            <span class="p">)</span> <span class="o">/</span> <span class="n">fs</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">gamma_z</span><span class="p">))</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isreal</span><span class="p">(</span><span class="n">gamma_z</span><span class="p">)):</span>
                <span class="n">f_pi</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">erfc</span><span class="p">(</span><span class="o">-</span><span class="n">gamma_z</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
                <span class="c1"># sort descend</span>
                <span class="n">f_pi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">f_pi</span><span class="p">)[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">p_less</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span>
                    <span class="mi">1</span> <span class="o">-</span> <span class="n">f_pi</span><span class="p">[</span><span class="mi">0</span> <span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">D</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">f_pi</span><span class="p">))]</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">p_less</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="n">do_gp_calibration</span> <span class="o">=</span> <span class="kc">True</span>

            <span class="c1"># Consider whether to stop polling</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="s2">&quot;complete_poll&quot;</span><span class="p">]:</span>
                <span class="c1"># Stop polling if last poll was good</span>
                <span class="k">if</span> <span class="n">certain_good_poll</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">do_gp_calibration</span><span class="p">:</span>
                        <span class="k">break</span>  <span class="c1"># GP is unreliable, just stop polling</span>
                    <span class="k">elif</span> <span class="n">p_less</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="s2">&quot;tol_poi&quot;</span><span class="p">]:</span>
                        <span class="k">break</span>  <span class="c1"># Use GP prediction whether to stop polling</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># No good polling so far -- if GP is reliable, stop polling</span>
                    <span class="c1"># If probability of improvement at any location is to low</span>
                    <span class="k">if</span> <span class="p">(</span>
                        <span class="ow">not</span> <span class="n">do_gp_calibration</span>
                        <span class="ow">and</span> <span class="p">(</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="s2">&quot;consecutive_skipping&quot;</span><span class="p">]</span>
                            <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">last_skipped</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">optim_state</span><span class="p">[</span><span class="s2">&quot;iter&quot;</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span>
                        <span class="p">)</span>
                        <span class="ow">and</span> <span class="n">poll_count</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="s2">&quot;min_failed_poll_steps&quot;</span><span class="p">]</span>
                        <span class="ow">and</span> <span class="n">p_less</span> <span class="o">&gt;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="s2">&quot;tol_poi&quot;</span><span class="p">])</span>
                    <span class="p">):</span>

                        <span class="bp">self</span><span class="o">.</span><span class="n">last_skipped</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">optim_state</span><span class="p">[</span><span class="s2">&quot;iter&quot;</span><span class="p">]</span>
                        <span class="k">break</span>

            <span class="c1"># Evaluate function and store the value</span>
            <span class="n">u_new</span> <span class="o">=</span> <span class="n">u_poll</span><span class="p">[</span><span class="n">index_acq</span><span class="p">]</span>
            <span class="n">y_poll</span><span class="p">,</span> <span class="n">y_sd_poll</span><span class="p">,</span> <span class="n">f_idx_new</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">function_logger</span><span class="p">(</span><span class="n">u_new</span><span class="p">)</span>

            <span class="c1"># Remove polled vector from set.</span>
            <span class="n">u_poll</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">u_poll</span><span class="p">,</span> <span class="n">index_acq</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

            <span class="c1"># Save statistics of gp prediction</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_save_gp_stats_</span><span class="p">(</span><span class="n">y_poll</span><span class="p">,</span> <span class="n">f_mu</span><span class="p">[</span><span class="n">index_acq</span><span class="p">]</span><span class="o">.</span><span class="n">item</span><span class="p">(),</span>
                                <span class="n">fs</span><span class="p">[</span><span class="n">index_acq</span><span class="p">]</span><span class="o">.</span><span class="n">item</span><span class="p">())</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">optim_state</span><span class="p">[</span><span class="s2">&quot;uncertainty_handling_level&quot;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># Update posterior with the new polled point</span>
                <span class="n">gp</span> <span class="o">=</span> <span class="n">add_and_update_gp</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">function_logger</span><span class="p">,</span>
                    <span class="n">gp</span><span class="p">,</span>
                    <span class="n">u_new</span><span class="p">,</span>
                    <span class="n">y_poll</span><span class="p">,</span>
                    <span class="n">y_sd_poll</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">,</span>
                <span class="p">)</span>  <span class="c1"># u_new is already added from the function logger</span>
                <span class="n">f_poll</span><span class="p">,</span> <span class="n">f_sd_poll</span> <span class="o">=</span> <span class="n">gp</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">u_new</span><span class="p">))</span>
                <span class="n">f_sd_poll</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">f_sd_poll</span><span class="p">)</span><span class="o">.</span><span class="n">item</span><span class="p">()</span>
                <span class="n">f_poll</span> <span class="o">=</span> <span class="n">f_poll</span><span class="o">.</span><span class="n">item</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">f_poll</span> <span class="o">=</span> <span class="n">y_poll</span>
                <span class="n">f_sd_poll</span> <span class="o">=</span> <span class="mi">0</span>

            <span class="n">poll_improvement</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_eval_improvement_</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">fval</span><span class="p">,</span>
                <span class="n">f_poll</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">fsd</span><span class="p">,</span>
                <span class="n">f_sd_poll</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="s2">&quot;improvement_quantile&quot;</span><span class="p">],</span>
            <span class="p">)</span>

            <span class="c1"># Check if current point improves over best polled point so far</span>
            <span class="k">if</span> <span class="n">poll_improvement</span> <span class="o">&gt;</span> <span class="n">poll_best_improvement</span><span class="p">:</span>
                <span class="n">u_poll_best</span> <span class="o">=</span> <span class="n">u_new</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="n">y_poll_best</span> <span class="o">=</span> <span class="n">y_poll</span>
                <span class="n">f_poll_best</span> <span class="o">=</span> <span class="n">f_poll</span>
                <span class="n">f_sd_poll_best</span> <span class="o">=</span> <span class="n">f_sd_poll</span>
                <span class="n">gp_poll_hyp_best</span> <span class="o">=</span> <span class="n">gp</span><span class="o">.</span><span class="n">get_hyperparameters</span><span class="p">(</span><span class="n">as_array</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="n">poll_best_improvement</span> <span class="o">=</span> <span class="n">poll_improvement</span>

                <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="s2">&quot;stobads&quot;</span><span class="p">]:</span>
                    <span class="n">certain_good_poll</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="n">poll_best_improvement</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">sufficient_improvement</span>
                    <span class="p">)</span>

            <span class="c1"># StoBads</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="s2">&quot;stobads&quot;</span><span class="p">]:</span>
                <span class="n">sto_success</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sto_success_improvement_</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">fval</span><span class="p">,</span>
                    <span class="n">f_poll</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">fsd</span><span class="p">,</span>
                    <span class="n">f_sd_poll</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">mesh_size</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">gamma_uncertain_interval</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="n">certain_good_poll</span> <span class="o">=</span> <span class="n">sto_success</span> <span class="o">==</span> <span class="mi">1</span>

            <span class="c1"># Increase poll counter</span>
            <span class="n">poll_count</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="c1"># End poll loop</span>

        <span class="c1"># Evaluate poll</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="s2">&quot;stobads&quot;</span><span class="p">]:</span>
            <span class="k">if</span> <span class="p">(</span>
                <span class="n">poll_best_improvement</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="s2">&quot;sloppy_improvement&quot;</span><span class="p">]</span>
            <span class="p">)</span> <span class="ow">or</span> <span class="n">poll_best_improvement</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">sufficient_improvement</span><span class="p">:</span>

                <span class="c1"># Update incumbent point (self.yval, self.fval, self.fsd) and optim_state</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_update_incumbent_</span><span class="p">(</span>
                    <span class="n">u_poll_best</span><span class="p">,</span> <span class="n">y_poll_best</span><span class="p">,</span> <span class="n">f_poll_best</span><span class="p">,</span> <span class="n">f_sd_poll_best</span>
                <span class="p">)</span>
                <span class="n">is_poll_moved</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">is_poll_moved</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># StoBads</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="s2">&quot;opp_stobads&quot;</span><span class="p">]</span> <span class="ow">and</span> <span class="n">sto_success</span> <span class="o">&gt;</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_update_incumbent_</span><span class="p">(</span>
                    <span class="n">u_poll_best</span><span class="p">,</span> <span class="n">y_poll_best</span><span class="p">,</span> <span class="n">f_poll_best</span><span class="p">,</span> <span class="n">f_sd_poll_best</span>
                <span class="p">)</span>
                <span class="n">is_poll_moved</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">elif</span> <span class="n">certain_good_poll</span><span class="p">:</span>
                <span class="c1"># Update incumbent point (self.yval, self.fval, self.fsd) and optim_state</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_update_incumbent_</span><span class="p">(</span>
                    <span class="n">u_poll_best</span><span class="p">,</span> <span class="n">y_poll_best</span><span class="p">,</span> <span class="n">f_poll_best</span><span class="p">,</span> <span class="n">f_sd_poll_best</span>
                <span class="p">)</span>
                <span class="n">is_poll_moved</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">is_poll_moved</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="k">if</span> <span class="n">certain_good_poll</span><span class="p">:</span>
            <span class="n">is_sucess_poll_flag</span> <span class="o">=</span> <span class="kc">True</span>

            <span class="c1"># Check if mesh size is already maximal</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_check_mesh_overflow_</span><span class="p">()</span>
            <span class="c1"># Successful poll, increase mesh size</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mesh_size_integer</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">mesh_size_integer</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="s2">&quot;max_poll_grid_number&quot;</span><span class="p">]</span>
            <span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">optim_state</span><span class="p">[</span><span class="s2">&quot;u_success&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">u_best</span><span class="o">.</span><span class="n">copy</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">optim_state</span><span class="p">[</span><span class="s2">&quot;y_success&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">yval</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">optim_state</span><span class="p">[</span><span class="s2">&quot;f_success&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fval</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">is_sucess_poll_flag</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="c1"># Failed poll, decrease mesh size</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mesh_size_integer</span> <span class="o">-=</span> <span class="mi">1</span>

            <span class="c1"># Accelerated mesh reduction if certain unsucessfull or  stalling</span>
            <span class="c1"># if self.options[&#39;stobads&#39;] and sto_success &lt; 0:</span>
            <span class="c1"># certain unsucessfull poll</span>
            <span class="c1">#        self.mesh_size_integer -= 1</span>
            <span class="c1"># else:</span>
            <span class="c1"># Check stalling</span>
            <span class="nb">iter</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">optim_state</span><span class="p">[</span><span class="s2">&quot;iter&quot;</span><span class="p">]</span>
            <span class="k">if</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="s2">&quot;accelerate_mesh&quot;</span><span class="p">]</span>
                <span class="ow">and</span> <span class="nb">iter</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="s2">&quot;accelerate_mesh_steps&quot;</span><span class="p">]</span>
            <span class="p">):</span>
                <span class="n">f_base</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">iteration_history</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;fval&quot;</span><span class="p">)[</span>
                    <span class="nb">iter</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="s2">&quot;accelerate_mesh_steps&quot;</span><span class="p">]</span>
                <span class="p">]</span>
                <span class="n">f_sd_base</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">iteration_history</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;fsd&quot;</span><span class="p">)[</span>
                    <span class="nb">iter</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="s2">&quot;accelerate_mesh_steps&quot;</span><span class="p">]</span>
                <span class="p">]</span>
                <span class="n">u_base</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">iteration_history</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;u&quot;</span><span class="p">)[</span>
                    <span class="nb">iter</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="s2">&quot;accelerate_mesh_steps&quot;</span><span class="p">]</span>
                <span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">f_q_historic_improvement</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_eval_improvement_</span><span class="p">(</span>
                    <span class="n">f_base</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">fval</span><span class="p">,</span>
                    <span class="n">f_sd_base</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">fsd</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="s2">&quot;improvement_quantile&quot;</span><span class="p">],</span>
                <span class="p">)</span>
                <span class="k">if</span> <span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">f_q_historic_improvement</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="s2">&quot;tol_fun&quot;</span><span class="p">]</span>
                <span class="p">):</span>  <span class="c1"># or np.all(u_base.flatten() == self.u.flatten()):</span>

                    <span class="bp">self</span><span class="o">.</span><span class="n">mesh_size_integer</span> <span class="o">-=</span> <span class="mi">1</span>
                    <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
                        <span class="s2">&quot;bads: The optimization is stalling, further decrease of the mesh size&quot;</span>
                    <span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">optim_state</span><span class="p">[</span><span class="s2">&quot;search_size_integer&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">optim_state</span><span class="p">[</span><span class="s2">&quot;search_size_integer&quot;</span><span class="p">],</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">mesh_size_integer</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="s2">&quot;search_grid_multiplier&quot;</span><span class="p">]</span>
                <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="s2">&quot;search_grid_number&quot;</span><span class="p">],</span>
            <span class="p">)</span>

            <span class="c1"># TODO: Profile plot iteration</span>

        <span class="c1"># End POLL evaluation</span>

        <span class="c1"># Update mesh size</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mesh_size</span> <span class="o">=</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="s2">&quot;poll_mesh_multiplier&quot;</span><span class="p">]</span> <span class="o">**</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh_size_integer</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">optim_state</span><span class="p">[</span><span class="s2">&quot;mesh_size&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh_size</span>

        <span class="c1"># Print iteration</span>
        <span class="k">if</span> <span class="n">is_sucess_poll_flag</span><span class="p">:</span>
            <span class="n">poll_string</span> <span class="o">=</span> <span class="s2">&quot;Successful poll&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">poll_string</span> <span class="o">=</span> <span class="s2">&quot;Refine grid&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">gp_refitted_flag</span><span class="p">:</span>
            <span class="n">action_str</span> <span class="o">=</span> <span class="s2">&quot;Train&quot;</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">gp_exit_flag</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">action_str</span> <span class="o">+=</span> <span class="s2">&quot; (failed)&quot;</span>
                <span class="c1"># self.gp_exit_flag = np.inf # Reset the flag</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logging_action</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">action_str</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">last_skipped</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">optim_state</span><span class="p">[</span><span class="s2">&quot;iter&quot;</span><span class="p">]:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logging_action</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;Skip&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_display_function_log_</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">optim_state</span><span class="p">[</span><span class="s2">&quot;iter&quot;</span><span class="p">],</span> <span class="n">poll_string</span><span class="p">)</span>

        <span class="c1"># TODO: if self.output_function is not None -&gt; Implement output function for saving the result in a file.</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">reset_gp</span> <span class="o">=</span> <span class="n">is_poll_moved</span>

        <span class="k">return</span> <span class="n">u_poll_best</span><span class="p">,</span> <span class="n">f_poll_best</span><span class="p">,</span> <span class="n">y_poll_best</span><span class="p">,</span> <span class="n">f_sd_poll_best</span><span class="p">,</span> <span class="n">gp</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_save_gp_stats_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fval</span><span class="p">,</span> <span class="n">ymu</span><span class="p">,</span> <span class="n">ys</span><span class="p">):</span>

        <span class="k">if</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">gp_stats</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;iter_gp&quot;</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">None</span>
            <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">gp_stats</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;iter_gp&quot;</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span>
        <span class="p">):</span>
            <span class="nb">iter</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">iter</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gp_stats</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;iter_gp&quot;</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">gp_stats</span><span class="o">.</span><span class="n">record</span><span class="p">(</span><span class="s2">&quot;iter_gp&quot;</span><span class="p">,</span> <span class="nb">iter</span><span class="p">,</span> <span class="nb">iter</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">gp_stats</span><span class="o">.</span><span class="n">record</span><span class="p">(</span><span class="s2">&quot;fval&quot;</span><span class="p">,</span> <span class="n">fval</span><span class="p">,</span> <span class="nb">iter</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">gp_stats</span><span class="o">.</span><span class="n">record</span><span class="p">(</span><span class="s2">&quot;ymu&quot;</span><span class="p">,</span> <span class="n">ymu</span><span class="p">,</span> <span class="nb">iter</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">gp_stats</span><span class="o">.</span><span class="n">record</span><span class="p">(</span><span class="s2">&quot;ys&quot;</span><span class="p">,</span> <span class="n">ys</span><span class="p">,</span> <span class="nb">iter</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_is_gp_refit_time_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alpha</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;A private method that checks the calibration of the GP prediction and if a fitting is required.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">function_logger</span><span class="o">.</span><span class="n">func_count</span> <span class="o">&lt;</span> <span class="mi">200</span><span class="p">:</span>
            <span class="n">refit_period</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">D</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">refit_period</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">D</span> <span class="o">*</span> <span class="mi">5</span>

        <span class="n">gp_iter_idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gp_stats</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;iter_gp&quot;</span><span class="p">)</span>

        <span class="n">do_gp_calibration</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="c1"># empty stats</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="n">gp_iter_idx</span> <span class="ow">is</span> <span class="kc">None</span>
            <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">gp_iter_idx</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span>
            <span class="ow">or</span> <span class="n">gp_iter_idx</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span>
        <span class="p">):</span>
            <span class="k">if</span> <span class="n">gp_iter_idx</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">gp_iter_idx</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">do_gp_calibration</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">gp_iter_idx</span> <span class="o">=</span> <span class="n">gp_iter_idx</span><span class="p">[</span>
                <span class="o">-</span><span class="mi">1</span>
            <span class="p">]</span>  <span class="c1"># retrieve last recorded gp stat iteration</span>

        <span class="c1"># if stats data is available check z_score</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">do_gp_calibration</span><span class="p">:</span>
            <span class="n">f_vals</span> <span class="o">=</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">gp_stats</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;fval&quot;</span><span class="p">)[:</span> <span class="n">gp_iter_idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
                <span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
                <span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;float&quot;</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="n">yvals</span> <span class="o">=</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">gp_stats</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;ymu&quot;</span><span class="p">)[:</span> <span class="n">gp_iter_idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
                <span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
                <span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;float&quot;</span><span class="p">)</span>
            <span class="p">)</span>
            
            <span class="n">zscore</span> <span class="o">=</span> <span class="n">f_vals</span> <span class="o">-</span> <span class="n">yvals</span>
            <span class="n">gp_ys</span> <span class="o">=</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">gp_stats</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;ys&quot;</span><span class="p">)[:</span> <span class="n">gp_iter_idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
                <span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
                <span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;float&quot;</span><span class="p">)</span>
            <span class="p">)</span>
            
            <span class="c1"># Avoid division by zero, sometimes the GP variance is zero (e.g at end of the optimization of a deterministic)</span>
            <span class="n">idx_zero_gp_ys</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="mf">0.</span><span class="p">,</span> <span class="n">gp_ys</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">gp_ys</span><span class="p">[</span><span class="n">idx_zero_gp_ys</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1e-6</span>
            
            <span class="n">zscore</span> <span class="o">=</span> <span class="n">zscore</span> <span class="o">/</span> <span class="n">gp_ys</span>

            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">zscore</span><span class="p">)):</span>
                <span class="n">do_gp_calibration</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">n</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">zscore</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span>
                    <span class="n">chi_to_inv</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">y</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="n">gammaincinv</span><span class="p">(</span><span class="n">v</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
                    <span class="n">plo</span> <span class="o">=</span> <span class="n">chi_to_inv</span><span class="p">(</span><span class="n">alpha</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
                    <span class="n">phi</span> <span class="o">=</span> <span class="n">chi_to_inv</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">alpha</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
                    <span class="n">total</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">zscore</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
                    <span class="k">if</span> <span class="p">(</span>
                        <span class="n">total</span> <span class="o">&lt;</span> <span class="n">plo</span>
                        <span class="ow">or</span> <span class="n">total</span> <span class="o">&gt;</span> <span class="n">phi</span>
                        <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">plo</span><span class="p">))</span>
                        <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">phi</span><span class="p">))</span>
                    <span class="p">):</span>
                        <span class="n">do_gp_calibration</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">do_gp_calibration</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">shapiro_test</span> <span class="o">=</span> <span class="n">shapiro</span><span class="p">(</span><span class="n">zscore</span><span class="p">)</span>
                    <span class="n">do_gp_calibration</span> <span class="o">=</span> <span class="n">shapiro_test</span><span class="o">.</span><span class="n">pvalue</span> <span class="o">&lt;</span> <span class="n">alpha</span>

        <span class="n">func_count</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">function_logger</span><span class="o">.</span><span class="n">func_count</span>

        <span class="n">refit_flag</span> <span class="o">=</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">optim_state</span><span class="p">[</span><span class="s2">&quot;lastfitgp&quot;</span><span class="p">]</span>
            <span class="o">&lt;</span> <span class="p">(</span><span class="n">func_count</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="s2">&quot;min_refit_time&quot;</span><span class="p">])</span>
            <span class="ow">and</span> <span class="p">(</span><span class="n">gp_iter_idx</span> <span class="o">&gt;=</span> <span class="n">refit_period</span> <span class="ow">or</span> <span class="n">do_gp_calibration</span><span class="p">)</span>
            <span class="ow">and</span> <span class="n">func_count</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">D</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="n">refit_flag</span><span class="p">:</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">optim_state</span><span class="p">[</span><span class="s2">&quot;lastfitgp&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">function_logger</span><span class="o">.</span><span class="n">func_count</span>

            <span class="c1"># Reset GP statistics GP</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">gp_stats</span> <span class="o">=</span> <span class="n">IterationHistory</span><span class="p">(</span>
                <span class="p">[</span>
                    <span class="s2">&quot;iter_gp&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;fval&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;ymu&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;ys&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;gp&quot;</span><span class="p">,</span>
                <span class="p">]</span>
            <span class="p">)</span>
            <span class="n">do_gp_calibration</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="k">return</span> <span class="n">refit_flag</span><span class="p">,</span> <span class="n">do_gp_calibration</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_get_target_from_gp_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">gp</span><span class="p">:</span> <span class="n">GP</span><span class="p">,</span> <span class="n">hyp_best</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;A private method that retrieve the prediction of the gp at the input ``u``.</span>
<span class="sd">            If the target function is stochastic then set the optimization target ``f_target`` slightly below the mean prediction.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">            u : np.array</span>
<span class="sd">                input point u</span>
<span class="sd">            gp : GP</span>
<span class="sd">            hyp_best : np.ndarray</span>
<span class="sd">                Hyperparameter used by the GP in the prediction</span>

<span class="sd">        Returns:</span>
<span class="sd">            f_target_mu :</span>
<span class="sd">                GP prediction, it corresponds to the mean values.</span>
<span class="sd">            f_target_s :</span>
<span class="sd">                GP variance/noise at point u.</span>
<span class="sd">            f_target : optimization target, it is slighly below the GP prediction when the target function is stochastic.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Corresponds to Matlab: updateTarget</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">optim_state</span><span class="p">[</span><span class="s2">&quot;uncertainty_handling_level&quot;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span>
            <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="s2">&quot;uncertain_incumbent&quot;</span><span class="p">]</span>
        <span class="p">):</span>
            <span class="n">tmp_gp</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">gp</span><span class="p">)</span>
            <span class="n">tmp_gp</span><span class="o">.</span><span class="n">set_hyperparameters</span><span class="p">(</span><span class="n">hyp_best</span><span class="p">)</span>
            <span class="n">f_target_mu</span><span class="p">,</span> <span class="n">fs2</span> <span class="o">=</span> <span class="n">tmp_gp</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">u</span><span class="p">))</span>

            <span class="n">f_target_s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">fs2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>
            <span class="k">if</span> <span class="p">(</span>
                <span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">f_target_mu</span><span class="p">)</span>
                <span class="o">|</span> <span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isreal</span><span class="p">(</span><span class="n">f_target_s</span><span class="p">)</span>
                <span class="o">|</span> <span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">f_target_s</span><span class="p">)</span>
            <span class="p">):</span>
                <span class="n">f_target_mu</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">optim_state</span><span class="p">[</span><span class="s2">&quot;fval&quot;</span><span class="p">]</span>
                <span class="n">f_target_s</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">optim_state</span><span class="p">[</span><span class="s2">&quot;fsd&quot;</span><span class="p">]</span>

            <span class="c1"># f_target: Set optimization target slightly below the current incumbent</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="s2">&quot;alternative_incumbent&quot;</span><span class="p">]:</span>
                <span class="n">f_target</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">f_target_mu</span>
                    <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">D</span><span class="p">)</span>
                    <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">function_logger</span><span class="o">.</span><span class="n">func_count</span><span class="p">)</span>
                    <span class="o">*</span> <span class="n">f_target_s</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">f_target</span> <span class="o">=</span> <span class="n">f_target_mu</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">optim_state</span><span class="p">[</span>
                    <span class="s2">&quot;sd_level&quot;</span>
                <span class="p">]</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">fs2</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="s2">&quot;tol_fun&quot;</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">f_target</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">optim_state</span><span class="p">[</span><span class="s2">&quot;fval&quot;</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="s2">&quot;tol_fun&quot;</span><span class="p">]</span>
            <span class="n">f_target_mu</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">optim_state</span><span class="p">[</span><span class="s2">&quot;fval&quot;</span><span class="p">]</span>
            <span class="n">f_target_s</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">return</span> <span class="n">f_target_mu</span><span class="p">,</span> <span class="n">f_target_s</span><span class="p">,</span> <span class="n">f_target</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_update_search_bounds_</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">lb</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">optim_state</span><span class="p">[</span><span class="s2">&quot;lb&quot;</span><span class="p">]</span>
        <span class="n">lb_search</span> <span class="o">=</span> <span class="n">force_to_grid</span><span class="p">(</span><span class="n">lb</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">optim_state</span><span class="p">[</span><span class="s2">&quot;search_mesh_size&quot;</span><span class="p">])</span>
        <span class="n">lb_search</span><span class="p">[</span><span class="n">lb_search</span> <span class="o">&lt;</span> <span class="n">lb</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">lb_search</span><span class="p">[</span><span class="n">lb_search</span> <span class="o">&lt;</span> <span class="n">lb</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">optim_state</span><span class="p">[</span><span class="s2">&quot;search_mesh_size&quot;</span><span class="p">]</span>
        <span class="p">)</span>

        <span class="n">ub</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">optim_state</span><span class="p">[</span><span class="s2">&quot;ub&quot;</span><span class="p">]</span>
        <span class="n">ub_search</span> <span class="o">=</span> <span class="n">force_to_grid</span><span class="p">(</span><span class="n">ub</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">optim_state</span><span class="p">[</span><span class="s2">&quot;search_mesh_size&quot;</span><span class="p">])</span>
        <span class="n">ub_search</span><span class="p">[</span><span class="n">ub_search</span> <span class="o">&gt;</span> <span class="n">ub</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">ub_search</span><span class="p">[</span><span class="n">ub_search</span> <span class="o">&gt;</span> <span class="n">ub</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">optim_state</span><span class="p">[</span><span class="s2">&quot;search_mesh_size&quot;</span><span class="p">]</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">lb_search</span><span class="p">,</span> <span class="n">ub_search</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_update_incumbent_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u_new</span><span class="p">,</span> <span class="n">yval_new</span><span class="p">,</span> <span class="n">fval_new</span><span class="p">,</span> <span class="n">fsd_new</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Move the incumbent (current point) to a new point.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">optim_state</span><span class="p">[</span><span class="s2">&quot;u&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">u_new</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">optim_state</span><span class="p">[</span><span class="s2">&quot;yval&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">yval_new</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">optim_state</span><span class="p">[</span><span class="s2">&quot;fval&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">fval_new</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">optim_state</span><span class="p">[</span><span class="s2">&quot;fsd&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">fsd_new</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">u</span> <span class="o">=</span> <span class="n">u_new</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">u_best</span> <span class="o">=</span> <span class="n">u_new</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">yval</span> <span class="o">=</span> <span class="n">yval_new</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fval</span> <span class="o">=</span> <span class="n">fval_new</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fsd</span> <span class="o">=</span> <span class="n">fsd_new</span>
        <span class="k">return</span> <span class="n">yval_new</span><span class="p">,</span> <span class="n">fval_new</span><span class="p">,</span> <span class="n">fsd_new</span>
        <span class="c1"># Update estimate of curvature (Hessian) - not supported (GP usage)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_update_search_stats_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">search_status</span><span class="p">,</span> <span class="n">search_dist</span><span class="p">):</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="ow">not</span> <span class="s2">&quot;search_stats&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">optim_state</span>
            <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">optim_state</span><span class="p">[</span><span class="s2">&quot;search_stats&quot;</span><span class="p">])</span> <span class="o">==</span> <span class="mi">0</span>
        <span class="p">):</span>
            <span class="n">search_stats</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="n">search_stats</span><span class="p">[</span><span class="s2">&quot;log_search_factor&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">search_stats</span><span class="p">[</span><span class="s2">&quot;success&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">search_stats</span><span class="p">[</span><span class="s2">&quot;udist&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">optim_state</span><span class="p">[</span><span class="s2">&quot;search_stats&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">search_stats</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">search_stats</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">optim_state</span><span class="p">[</span><span class="s2">&quot;search_stats&quot;</span><span class="p">]</span>

        <span class="n">search_stats</span><span class="p">[</span><span class="s2">&quot;log_search_factor&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">optim_state</span><span class="p">[</span><span class="s2">&quot;search_factor&quot;</span><span class="p">])</span>
        <span class="p">)</span>
        <span class="n">search_stats</span><span class="p">[</span><span class="s2">&quot;udist&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">search_dist</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">search_status</span> <span class="o">==</span> <span class="s2">&quot;success&quot;</span><span class="p">:</span>
            <span class="n">search_stats</span><span class="p">[</span><span class="s2">&quot;success&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mf">1.0</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">optim_state</span><span class="p">[</span><span class="s2">&quot;search_factor&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">optim_state</span><span class="p">[</span><span class="s2">&quot;search_factor&quot;</span><span class="p">]</span>
                <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="s2">&quot;search_scale_success&quot;</span><span class="p">]</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="s2">&quot;adaptive_incumbent_shift&quot;</span><span class="p">]:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">optim_state</span><span class="p">[</span><span class="s2">&quot;sd_level&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">optim_state</span><span class="p">[</span><span class="s2">&quot;sd_level&quot;</span><span class="p">]</span> <span class="o">*</span> <span class="mi">2</span>

        <span class="k">elif</span> <span class="n">search_status</span> <span class="o">==</span> <span class="s2">&quot;incremental&quot;</span><span class="p">:</span>
            <span class="n">search_stats</span><span class="p">[</span><span class="s2">&quot;success&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mf">0.5</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">optim_state</span><span class="p">[</span><span class="s2">&quot;search_factor&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">optim_state</span><span class="p">[</span><span class="s2">&quot;search_factor&quot;</span><span class="p">]</span>
                <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="s2">&quot;search_scale_incremental&quot;</span><span class="p">]</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="s2">&quot;adaptive_incumbent_shift&quot;</span><span class="p">]:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">optim_state</span><span class="p">[</span><span class="s2">&quot;sd_level&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">optim_state</span><span class="p">[</span><span class="s2">&quot;sd_level&quot;</span><span class="p">]</span> <span class="o">*</span> <span class="mi">2</span><span class="o">**</span><span class="mi">2</span>
                <span class="p">)</span>

        <span class="k">elif</span> <span class="n">search_status</span> <span class="o">==</span> <span class="s2">&quot;failure&quot;</span><span class="p">:</span>
            <span class="n">search_stats</span><span class="p">[</span><span class="s2">&quot;success&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mf">0.0</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">optim_state</span><span class="p">[</span><span class="s2">&quot;search_factor&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">optim_state</span><span class="p">[</span><span class="s2">&quot;search_factor&quot;</span><span class="p">]</span>
                <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="s2">&quot;search_scale_failure&quot;</span><span class="p">]</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="s2">&quot;adaptive_incumbent_shift&quot;</span><span class="p">]:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">optim_state</span><span class="p">[</span><span class="s2">&quot;sd_level&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="s2">&quot;incumbent_sigma_multiplier&quot;</span><span class="p">],</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">optim_state</span><span class="p">[</span><span class="s2">&quot;sd_level&quot;</span><span class="p">]</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span>
                <span class="p">)</span>

        <span class="c1"># Reset search factor at the end of each search</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">optim_state</span><span class="p">[</span><span class="s2">&quot;search_count&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="s2">&quot;search_n_try&quot;</span><span class="p">]:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">optim_state</span><span class="p">[</span><span class="s2">&quot;search_factor&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

        <span class="k">return</span> <span class="n">search_stats</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_re_evaluate_history_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">gp</span><span class="p">:</span> <span class="n">GP</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;A private method used in the case of a stochastic target function.</span>
<span class="sd">        It updates the predicted values and the variance for each stored GP at each iteration, by computing the posterior on the current training set without refitting the parameters.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">optim_state</span><span class="p">[</span><span class="s2">&quot;last_re_eval&quot;</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">function_logger</span><span class="o">.</span><span class="n">func_count</span><span class="p">:</span>
            <span class="c1"># Re-evaluate gp outputs</span>
            <span class="n">u_history</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">iteration_history</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;u&quot;</span><span class="p">)</span>
            <span class="n">gps</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">iteration_history</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;gp&quot;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">u_history</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                <span class="n">tmp_gp</span> <span class="o">=</span> <span class="n">gps</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">u</span> <span class="o">=</span> <span class="n">u_history</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">tmp_gp</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">local_gp_fitting</span><span class="p">(</span>
                    <span class="n">tmp_gp</span><span class="p">,</span>
                    <span class="n">u</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">function_logger</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">optim_state</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">iteration_history</span><span class="p">,</span>
                    <span class="kc">False</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="n">fval</span><span class="p">,</span> <span class="n">fsd</span> <span class="o">=</span> <span class="n">tmp_gp</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">u</span><span class="p">))</span>
                <span class="n">fval</span> <span class="o">=</span> <span class="n">fval</span><span class="o">.</span><span class="n">item</span><span class="p">()</span>
                <span class="n">fsd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">fsd</span><span class="p">)</span><span class="o">.</span><span class="n">item</span><span class="p">()</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">iteration_history</span><span class="o">.</span><span class="n">record</span><span class="p">(</span><span class="s2">&quot;fval&quot;</span><span class="p">,</span> <span class="n">fval</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">iteration_history</span><span class="o">.</span><span class="n">record</span><span class="p">(</span><span class="s2">&quot;fsd&quot;</span><span class="p">,</span> <span class="n">fsd</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">optim_state</span><span class="p">[</span><span class="s2">&quot;last_re_eval&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">function_logger</span><span class="o">.</span><span class="n">func_count</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_check_mesh_overflow_</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh_size_integer</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="s2">&quot;max_poll_grid_number&quot;</span><span class="p">]:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mesh_overflows</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh_overflows</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="s2">&quot;mesh_overflow_warning&quot;</span><span class="p">]</span>
            <span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                    <span class="s2">&quot;bads:meshOverflow </span><span class="se">\t</span><span class="s2"> The mesh attempted to expand above maximum size too many times. Try widening plausible_lower_bounds and plausible_upper_bounds.&quot;</span>
                <span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_log_column_headers</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Private method to log the column headers for the iteration log.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">optim_state</span><span class="p">[</span><span class="s2">&quot;cache_active&quot;</span><span class="p">]:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                <span class="s2">&quot; Iteration f-count/f-cache     E[f(x)]     SD[f(x)]     MeshScale     Method       Actions&quot;</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">optim_state</span><span class="p">[</span><span class="s2">&quot;uncertainty_handling_level&quot;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                    <span class="s2">&quot; Iteration    f-count      E[f(x)]        SD[f(x)]           MeshScale          Method              Actions&quot;</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                    <span class="s2">&quot; Iteration    f-count         f(x)           MeshScale          Method             Actions&quot;</span>
                <span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_setup_logging_display_format</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Private method to set up the display format for logging the iterations.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">optim_state</span><span class="p">[</span><span class="s2">&quot;cache_active&quot;</span><span class="p">]:</span>
            <span class="n">display_format</span> <span class="o">=</span> <span class="s2">&quot; </span><span class="si">{:5.0f}</span><span class="s2">     </span><span class="si">{:5.0f}</span><span class="s2">/</span><span class="si">{:5.0f}</span><span class="s2">   </span><span class="si">{:12.6f}</span><span class="s2">  &quot;</span>
            <span class="n">display_format</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="si">{:12.6f}</span><span class="s2">  </span><span class="si">{:12.6f}</span><span class="s2">     </span><span class="si">{}</span><span class="s2">       </span><span class="si">{}</span><span class="s2">&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">optim_state</span><span class="p">[</span><span class="s2">&quot;uncertainty_handling_level&quot;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">display_format</span> <span class="o">=</span> <span class="s2">&quot; </span><span class="si">{:5.0f}</span><span class="s2">       </span><span class="si">{:5.0f}</span><span class="s2">    </span><span class="si">{:12.6g}</span><span class="s2">    &quot;</span>
                <span class="n">display_format</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="si">{:12.6g}</span><span class="s2">    </span><span class="si">{:12.6g}</span><span class="s2">      </span><span class="si">{:^20s}</span><span class="s2">        </span><span class="si">{}</span><span class="s2">&quot;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">display_format</span> <span class="o">=</span> <span class="s2">&quot; </span><span class="si">{:5.0f}</span><span class="s2">       </span><span class="si">{:5.0f}</span><span class="s2">    </span><span class="si">{:12.6g}</span><span class="s2">    &quot;</span>
                <span class="n">display_format</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="si">{:12.6g}</span><span class="s2">     </span><span class="si">{:^20s}</span><span class="s2">        </span><span class="si">{}</span><span class="s2">&quot;</span>

        <span class="k">return</span> <span class="n">display_format</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_display_function_log_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">iteration</span><span class="p">,</span> <span class="n">method</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">optim_state</span><span class="p">[</span><span class="s2">&quot;uncertainty_handling_level&quot;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">display_format</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="n">iteration</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">function_logger</span><span class="o">.</span><span class="n">func_count</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">fval</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">fsd</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">optim_state</span><span class="p">[</span><span class="s2">&quot;mesh_size&quot;</span><span class="p">],</span>
                    <span class="n">method</span><span class="p">,</span>
                    <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">logging_action</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]),</span>
                <span class="p">)</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">display_format</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="n">iteration</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">function_logger</span><span class="o">.</span><span class="n">func_count</span><span class="p">,</span>
                    <span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fval</span><span class="p">),</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">optim_state</span><span class="p">[</span><span class="s2">&quot;mesh_size&quot;</span><span class="p">],</span>
                    <span class="n">method</span><span class="p">,</span>
                    <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">logging_action</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]),</span>
                <span class="p">)</span>
            <span class="p">)</span></div>

</pre></div>

                </article>
              

              
              
              
              
                <footer class="prev-next-footer d-print-none">
                  
<div class="prev-next-area">
</div>
                </footer>
              
            </div>
            
            
              
            
          </div>
          <footer class="bd-footer-content">
            
<div class="bd-footer-content__inner container">
  
  <div class="footer-item">
    
<p class="component-author">
By Author name not set
</p>

  </div>
  
  <div class="footer-item">
    

  <p class="copyright">
    
       Copyright 2022, Machine and Human Intelligence research group (PI: Luigi Acerbi, University of Helsinki).
      <br/>
    
  </p>

  </div>
  
  <div class="footer-item">
    
  </div>
  
  <div class="footer-item">
    
  </div>
  
</div>
          </footer>
        

      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../../../_static/scripts/bootstrap.js?digest=dfe6caa3a7d634c4db9b"></script>
<script src="../../../_static/scripts/pydata-sphinx-theme.js?digest=dfe6caa3a7d634c4db9b"></script>

  <footer class="bd-footer">
  </footer>
  </body>
</html>